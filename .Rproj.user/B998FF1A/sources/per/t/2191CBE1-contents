# Function to produce predictions where some, but not all covariates are NA

predict_passna <- function(mod, dat, n_const = 0, n_digits = NULL, ...) {
  # library(caret)  # Passed elsewhere
  # library(Cubist)  # Passed elsewhere
  rfun2 <- function(mod2, dat2, n_const2, n_digits2, ...) {
    notallnas <- rowSums(is.na(dat2)) < (ncol(dat2) - n_const2)
    out2 <- rep(NA, nrow(dat2))
    if (sum(notallnas) > 0) {
      out2[notallnas] <- predict(
        object = mod2,
        newdata = dat2[notallnas, ],
        na.action = na.pass,
        ...
      )
    }
    if (!is.null(n_digits2)) {
      out2 <- round(out2, digits = n_digits2)
    }
    return(out2)
  }
  out <- rfun2(mod, dat, n_const, n_digits, ...)
  return(out)
}

predict_passna_prob <- function(mod, dat, n_const = 0, n_digits = NULL, ...) {
  # library(caret)  # Passed elsewhere
  # library(Cubist)  # Passed elsewhere
  rfun2 <- function(mod2, dat2, n_const2, n_digits2, ...) {
    notallnas <- rowSums(is.na(dat2)) < (ncol(dat2) - n_const2)
    out2 <- matrix(
      NA,
      nrow = nrow(dat2),
      ncol = length(mod2$levels))
    if (sum(notallnas) > 0) {
      out2[notallnas, ] <- as.matrix(
        predict.train(
          object = mod2,
          newdata = dat2[notallnas, ],
          na.action = na.pass,
          type = "prob",
          ...
        )
      )
    }
    if (!is.null(n_digits2)) {
      out2 <- round(out2, digits = n_digits2)
    }
    return(out2)
  }
  out <- rfun2(mod, dat, n_const, n_digits, ...)
  return(out)
}

# END
