) %>%
raise_to_power(3) %>%
round(., digits = 1) %>%
set_names(prob_q_out_chr)
out[out < 0] <- 0
out[out > 60] <- 60
return(out)
}
numCores <- detectCores() - 1
numCores
showConnections()
cl <- makeCluster(numCores)
clusterEvalQ(
cl,
{
library(terra)
library(magrittr)
library(dplyr)
library(tools)
}
)
clusterExport(
cl,
c("dir_tiles_prob_peat",
"tile_numbers_chr",
"prob_q_out",
"calc_q_cbrt",
"tiles_mean_pse_cbrt",
"dir_dat",
"prob_q_out_chr",
"dir_tiles_peat_quantiles"
)
)
parSapplyLB(
cl,
1:length(tiles_mean_pse_cbrt),
function(x) {
tmpfolder <- paste0(dir_dat, "/Temp/")
terraOptions(memfrac = 0.02, tempdir = tmpfolder)
mean_pse_cbrt_x <- tiles_mean_pse_cbrt[x] %>%
rast()
outfile_tmp_x <- tmpfolder %>%
paste0(., "/peat_qs_tile", tile_numbers_chr[x], ".tif")
app(
mean_pse_cbrt_x,
fun = calc_q_cbrt,
filename = outfile_tmp_x,
overwrite = TRUE,
wopt = list(
gdal = "TILED=YES",
datatype = "FLT4S"
)
)
my_qs <- outfile_tmp_x %>% rast()
outdir_tile_x <- dir_tiles_peat_quantiles %>%
paste0(., "/tile_", tile_numbers_chr[x], "/") %T>%
dir.create()
for (i in 1:nlyr(my_qs)) {
outname_base <- paste0("soc_", prob_q_out_chr[i])
outfile_xi <- outdir_tile_x %>%
paste0(., outname_base, ".tif")
writeRaster(
my_qs[[i]],
filename = outfile_xi,
names = outname_base,
overwrite = TRUE,
gdal = "TILED=YES",
datatype = "FLT4S"
)
}
return(NULL)
}
)
stopCluster(cl)
foreach::registerDoSEQ()
rm(cl)
tilenames <- tile_numbers_chr %>%
paste0("tile_")
outfiles_basenames <- paste0(
dir_tiles_peat_quantiles, "/", tilenames[1], "/") %>%
list.files() %>%
basename() %>%
tools::file_path_sans_ext()
paste0(
dir_tiles_peat_quantiles, "/", tilenames[1], "/")
tilenames <- tile_numbers_chr %>%
paste0("tile_", .)
outfiles_basenames <- paste0(
dir_tiles_peat_quantiles, "/", tilenames[1], "/") %>%
list.files() %>%
basename() %>%
tools::file_path_sans_ext()
tilenames <- tile_numbers_chr %>%
paste0("tile_", .)
outfiles_basenames <- paste0(
dir_tiles_peat_quantiles, "/", tilenames[1], "/") %>%
list.files() %>%
basename() %>%
tools::file_path_sans_ext()
# dir_merged_depth <- dir_pred_boot %>%
#   paste0(
#     ., "/final_maps/depth_", breaks_j_chr[1], "_", breaks_j_chr[2], "_cm/"
#   ) %T>%
#   dir.create(showWarnings = FALSE, recursive = TRUE)
for (i in 1:length(outfiles_basenames)) {
summary_tiles_i <- paste0(
dir_tiles_peat_quantiles, "/", tilenames, "/",
outfiles_basenames[i], ".tif"
)
tile1_i <- summary_tiles_i[1] %>% rast()
dtyp_i <- datatype(tile1_i)
naflag_i <- NAflag(tile1_i)
if (dtyp_i == "INT1U") { naflag_i <- 101 }
if (!is.finite(naflag_i)) { naflag_i <- -1}
outtiles_sprc <- summary_tiles_i %>% sprc()
merge(
outtiles_sprc,
filename = paste0(dir_new_maps, "/", outfiles_basenames[i], ".tif"),
overwrite = TRUE,
gdal = "TILED=YES",
datatype = dtyp_i,
NAflag = naflag_i,
names = outfiles_basenames[i]
)
}
soc6pct_log <- log(6)
# Map class uncertainties for SOC
# Only topsoil
library(parallel)
library(caret)
library(terra)
library(magrittr)
library(dplyr)
library(xgboost)
library(foreach)
library(stringr)
library(tools) # file_path_sans_ext
dir_code <- getwd()
root <- dirname(dir_code)
dir_dat <- paste0(root, "/digijord_data/")
testn <- 14
mycrs <- "EPSG:25832"
dir_results <- dir_dat %>%
paste0(., "/results_test_", testn, "/")
fractions_alt <- c("clay", "silt", "fine_sand", "coarse_sand", "SOC", "CaCO3")
fractions <- fractions_alt
frac_ind_mineral <- c(1:4)
frac_ind_predict <- c(1:length(fractions))[-3]  # Exclude fine sand
fraction_names <- c(
"Clay", "Silt", "Fine sand", "Coarse sand", "SOC", "CaCO3"
)
fraction_names_underscore <- c(
"Clay", "Silt", "Fine_sand", "Coarse_sand", "SOC", "CaCO3"
)
dir_cov <- dir_dat %>% paste0(., "/covariates")
cov_files <- dir_cov %>% list.files()
cov_names <- cov_files %>% tools::file_path_sans_ext()
cov_cats <- dir_code %>%
paste0(., "/cov_categories_20231110.csv") %>%
read.table(
sep = ",",
header = TRUE
)
# cov_selected <- cov_cats %>%
#   filter(anbm_use == 1) %>%
#   dplyr::select(., name) %>%
#   unlist() %>%
#   unname()
source("f_predict_passna.R")
source("f_classify_SOC.R")
source("f_classify_soil_JB.R")
# SOC classes
SOC_levels <- c(3, 6, 12, 60)
SOC_labels <- c("00_03", "03_06", "06_12", "12_60")
# For peat probabilities and confidence intervals
soc6pct_log <- log(6)
prob_q_out <- c(0.5, 2.5, 5.0, 16.0, 84.0, 95.0, 97.5, 99.5)/100
prob_q_out_chr <- prob_q_out %>%
multiply_by(1000) %>%
formatC(width = 4, flag = "0") %>%
paste0("p", .)
# Calculate mean logSOC prediction and MSE for logsoc
obs_texture <- paste0(dir_results, "/observations_texture.rds") %>%
readRDS()
models_boot_predictions_soc <- dir_boot %>%
paste0(., "/models_boot_predictions_SOC.rds") %>%
readRDS()
dir_boot <- dir_results %>%
paste0(., "/bootstrap/")
models_boot_predictions_soc <- dir_boot %>%
paste0(., "/models_boot_predictions_SOC.rds") %>%
readRDS()
models_weights_soc <- dir_results %>%
paste0(., "/models_weights_SOC.rds") %>%
readRDS()
models_boot_predictions_soc
models_weights_soc
logsoc_mean_prediction <- models_boot_predictions_soc %>%
log() %>%
apply(., 1, mean)
logsoc_mean_prediction
# Load combination raster showing parts covered by TÃ¸rv2022 and my own map.
SOC_combination_map <- root %>%
paste0(
., "/Texture_maps_10m/depth_000_030_cm/Kulstof2022_000_030_cm/",
"Kulstof_arealkombination.tif") %>%
rast()
SOC_combination_map <- root %>%
paste0(
., "/Soil_maps_10m_new/Kulstof2022\SOC_000_030_cm/",
SOC_combination_map <- root %>%
paste0(
., "/Soil_maps_10m_new/Kulstof2022/SOC_000_030_cm/",
"SOC_combination_000_030_cm.tif") %>%
rast()
SOC_combination <- obs_texture %>%
vect(geom = c("UTMX", "UTMY"), crs = mycrs) %>%
terra::extract(x = SOC_combination_map, y = .)
SOC_combination
logSOC_df <- obs_texture %>%
select(c(ID_new, db, ID_old, upper, lower, SOC, imputed, fold)) %>%
mutate(
observed = log(SOC),
predicted = logsoc_mean_prediction,
w = models_weights_soc,
combination = SOC_combination$Band_1,
mean_depth = (upper + lower) / 2
) %>%
filter(
is.finite(SOC),
is.finite(predicted),
is.finite(w),
imputed == FALSE,
is.finite(mean_depth)
)
logSOC_df <- obs_texture %>%
select(c(ID_new, db, ID_old, upper, lower, SOC, imputed, fold)) %>%
mutate(
observed = log(SOC),
predicted = logsoc_mean_prediction,
w = models_weights_soc,
combination = SOC_combination$Band_1,
indices = factor(!fold == 10, labels = c("CV", "Holdout")),
mean_d = (upper + lower)/2,
depth = cut(mean_d, breaks, include.lowest = TRUE)
) %>%
filter(
is.finite(SOC),
is.finite(predicted),
is.finite(w),
imputed == FALSE,
is.finite(mean_depth)
)
breaks <- c(0, 30, 60, 100, 200)
logSOC_df <- obs_texture %>%
select(c(ID_new, db, ID_old, upper, lower, SOC, imputed, fold)) %>%
mutate(
observed = log(SOC),
predicted = logsoc_mean_prediction,
w = models_weights_soc,
combination = SOC_combination$Band_1,
indices = factor(!fold == 10, labels = c("CV", "Holdout")),
mean_d = (upper + lower)/2,
depth = cut(mean_d, breaks, include.lowest = TRUE)
) %>%
filter(
is.finite(SOC),
is.finite(predicted),
is.finite(w),
imputed == FALSE,
is.finite(mean_depth)
)
breaks <- c(0, 30, 60, 100, 200)
logSOC_df <- obs_texture %>%
select(c(ID_new, db, ID_old, upper, lower, SOC, imputed, fold)) %>%
mutate(
observed = log(SOC),
predicted = logsoc_mean_prediction,
w = models_weights_soc,
combination = SOC_combination$Band_1,
indices = factor(!fold == 10, labels = c("CV", "Holdout")),
mean_d = (upper + lower)/2,
depth = cut(mean_d, breaks, include.lowest = TRUE)
) %>%
filter(
is.finite(SOC),
is.finite(predicted),
is.finite(w),
imputed == FALSE,
is.finite(mean_d)
)
logSOC_df
?mse
?MSE
install.packages("MetricsWeighted")
library(MetricsWeighted)
logSOC_df %>%
group_by(
indices, depth
) %>%
summarise(
r2w = round(get_R2w(cbind(predicted, observed), w), digits = 3),
rmsew = round(get_RMSEw(cbind(predicted, observed), w), digits = 3),
msew = MetricsWeighted::mse(observed, predicted, w = w)
)
logSOC_df %>%
group_by(
indices, depth
) %>%
summarise(
# r2w = round(get_R2w(cbind(predicted, observed), w), digits = 3),
# rmsew = round(get_RMSEw(cbind(predicted, observed), w), digits = 3),
msew = MetricsWeighted::mse(observed, predicted, w = w)
)
logSOC_df <- obs_texture %>%
select(c(ID_new, db, ID_old, upper, lower, SOC, imputed, fold)) %>%
mutate(
observed = log(SOC),
predicted = logsoc_mean_prediction,
w = models_weights_soc,
combination = SOC_combination$Band_1,
indices = factor(!fold == 10, labels = c("CV", "Holdout")),
mean_d = (upper + lower)/2,
depth = cut(mean_d, breaks, include.lowest = TRUE)
) %>%
filter(
is.finite(SOC),
is.finite(predicted),
is.finite(w),
imputed == FALSE,
is.finite(mean_d),
is.finite(depth)
)
logSOC_df %>%
group_by(
indices, depth
) %>%
summarise(
# r2w = round(get_R2w(cbind(predicted, observed), w), digits = 3),
# rmsew = round(get_RMSEw(cbind(predicted, observed), w), digits = 3),
msew = MetricsWeighted::mse(observed, predicted, w = w)
)
logSOC_df
?mse
logSOC_df %>% filter(SOC == 0)
log(0.1)
log(0.2)
exp(-4)
logSOC_df <- obs_texture %>%
select(c(ID_new, db, ID_old, upper, lower, SOC, imputed, fold)) %>%
mutate(
SOC = case_when(
SOC == 0 ~ 0.01831564,
.default = SOC
),
observed = log(SOC),
predicted = logsoc_mean_prediction,
w = models_weights_soc,
combination = SOC_combination$Band_1,
indices = factor(!fold == 10, labels = c("CV", "Holdout")),
mean_d = (upper + lower)/2,
depth = cut(mean_d, breaks, include.lowest = TRUE)
) %>%
filter(
is.finite(SOC),
is.finite(predicted),
is.finite(w),
imputed == FALSE,
is.finite(mean_d),
is.finite(depth)
)
logSOC_df %>% filter(SOC == 0)
logSOC_df %>% filter(SOC < 0.3)
obs_texture$SOC
logSOC_df %>%
group_by(
indices, depth
) %>%
summarise(
# r2w = round(get_R2w(cbind(predicted, observed), w), digits = 3),
# rmsew = round(get_RMSEw(cbind(predicted, observed), w), digits = 3),
msew = MetricsWeighted::mse(observed, predicted, w = w)
)
logsoc_mse_all <- logSOC_df %>%
group_by(
indices, depth
) %>%
summarise(
# r2w = round(get_R2w(cbind(predicted, observed), w), digits = 3),
# rmsew = round(get_RMSEw(cbind(predicted, observed), w), digits = 3),
msew = MetricsWeighted::mse(observed, predicted, w = w)
)
logsoc_mse_splitpeat2022 <- logSOC_df %>%
group_by(
indices, depth, combination
) %>%
summarise(
# r2w = round(get_R2w(cbind(predicted, observed), w), digits = 3),
# rmsew = round(get_RMSEw(cbind(predicted, observed), w), digits = 3),
msew = MetricsWeighted::mse(observed, predicted, w = w)
)
logsoc_mse_splitpeat2022
logsoc_mse_splitpeat2022 <- logSOC_df %>%
group_by(
indices, depth, combination
) %>%
summarise(
# r2w = round(get_R2w(cbind(predicted, observed), w), digits = 3),
# rmsew = round(get_RMSEw(cbind(predicted, observed), w), digits = 3),
msew = MetricsWeighted::mse(observed, predicted, w = w)
) %>%
arrange(combination)
logsoc_mse_splitpeat2022
logSOC_df %>% group_by(combination) %>% summarise(mean = mean(observed))
logsoc_mse_all %>%
filter(indices == "CV") %>%
select(msew) %>%
unlist() %>%
unname()
logsoc_mse_all %>%
ungroup() %>%
filter(indices == "CV") %>%
select(msew) %>%
unlist() %>%
unname()
logsoc_mse_depths <- logsoc_mse_all %>%
ungroup() %>%
filter(indices == "CV") %>%
select(msew) %>%
unlist() %>%
unname()
?var
calc_log_mean_var <- function(x) {
x %<>% log()
out <- c(
mean(x, na.rm = TRUE),
var(x, na.rm = TRUE)
)
return(out)
}
calc_log_mean_var(runif(100))
calc_log_mean_var(runif(100)*10)
soc6pct_log
calc_log_mean_var(c(runif(100)*10, NA))
calc_log_mean_var(2)
calc_log_mean_var(c(2,2))
calc_log_mean_pse <- function(x, mse) {
x %<>% log()
out <- c(
mean(x, na.rm = TRUE),
var(x, na.rm = TRUE)
)
return(out)
}
calc_log_mean_pse <- function(x, mse_log) {
x %<>% log()
out <- c(
mean(x, na.rm = TRUE),
sqrt(var(x, na.rm = TRUE) + mse_log)
)
return(out)
}
calc_log_mean_pse(c(2,2), 0.5)
calc_log_mean_pse(c(2,2), 0.2)
calc_log_mean_pse(c(2,2), -0.5)
calc_log_mean_pse(c(2,2), 10)
rm(calc_log_mean_var())
rm(calc_log_mean_var
)
?apply(array, margin, ...)
?app
calc_prob_q <- function(x, q) {
out <- pnorm(
q = q,
mean = x[1],
sd = x[2],
lower.tail = FALSE
) %>%
round(., digits = 3) %>%
multiply_by(100)
return(out)
}
calc_q_log <- function (x) {
out <- qnorm(
p = prob_q_out,
mean = x[1],
sd = x[2]
) %>%
exp(3) %>%
round(., digits = 1) %>%
set_names(prob_q_out_chr)
out[out < 0] <- 0
out[out > 60] <- 60
return(out)
}
calc_q_log(c(1, 0.5))
calc_q_log <- function (x) {
out <- qnorm(
p = prob_q_out,
mean = x[1],
sd = x[2]
) %>%
exp() %>%
round(., digits = 1) %>%
set_names(prob_q_out_chr)
out[out < 0] <- 0
out[out > 60] <- 60
return(out)
}
calc_q_log(c(1, 0.5))
calc_q_log(c(1, 0.5)) %>% plot())
calc_q_log(c(1, 0.5)) %>% plot()
