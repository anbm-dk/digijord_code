w = filt,
fun = "sum",
na.policy = "all",
na.rm = TRUE
)
out2 <- list()
# out2$mean <- smooth_prod / smooth_count
out2$mean <- NA
out2$count <- smooth_count
out2$prod <- smooth_prod
return(out2)
}
# Function for weighted aggregation (using product x*x_count)
agg_weight <- function(prod, x_count) {
prod_agg <- terra::aggregate(
prod,
fun = "sum",
na.rm = TRUE
)
count_agg <- terra::aggregate(
x_count,
fun = "sum",
na.rm = TRUE
)
out2 <- list()
# out2$mean <- prod_agg / count_agg
out2$mean <- NA
out2$count <- count_agg
out2$prod <- prod_agg
return(out2)
}
# Function for projecting maps, weights and products
project_weight <- function(x, targ, dtyp) {
out2 <- list()
# out2$x <- terra::project(
#   x = x[[1]],
#   y = targ,
#   method = "near",
#   datatype = dtyp
# )
out2$x <- NA
out2$x_count <- terra::project(
x = x[[2]] / 4,  # NB
y = targ,
method = "near"
)
out2$prod <- terra::project(
x = x[[3]] / 4,  # NB
y = targ,
method = "near"
)
return(out2)
}
# Function for merging maps and weights
merge_weight <- function(x, y, dtyp) {
emptycells <- x[[3]] == 0
out2 <- list()
# out2$x <- terra::merge(
#   x = x[[1]],
#   y = y[[1]],
#   wopt = list(datatype = dtyp)
# )
out2$x <- NA
out2$x_count <- terra::ifel(
emptycells,
yes = y[[2]],
no = x[[2]]
)
out2$prod <- terra::ifel(
emptycells,
yes = y[[3]],
no = x[[3]]
)
return(out2)
}
# Stepwise aggregation
for (i in 2:nsteps) {
smoothed_down <- smooth_weight(
prod = aggregated_list[[i - 1]][[3]],
x_count = aggregated_list[[i - 1]][[2]],
myfilter1
)
aggregated_list[[i]] <- agg_weight(
prod = smoothed_down[[3]],
x_count = smoothed_down[[2]]
)
}
smooth_up_list[[nsteps]] <- aggregated_list[[nsteps]]
# Stepwise disaggregation
for (i in (nsteps - 1):1) {
# Disaggregate by 2
splitted <- project_weight(
x = smooth_up_list[[i + 1]],
targ = aggregated_list[[i]][[2]],
dtyp = datatype(inrast)
)
# Merge means and counts
merged <- merge_weight(
x = aggregated_list[[i]],
y = splitted,
dtyp = datatype(inrast)
)
# Weighted smoothing
smooth_up_list[[i]] <- smooth_weight(
prod = merged[[3]],
x_count = merged[[2]],
filt = myfilter2
)
}
final_lyr <- smooth_up_list[[1]][[3]] / smooth_up_list[[1]][[2]]
out <- list()
out$final <- terra::merge(
inrast,
final_lyr,
wopt = list(datatype = datatype(inrast))
)
out$aggregated_list <- aggregated_list
out$smooth_up_list <- smooth_up_list
return(out)
}
f <- system.file("ex/elev.tif", package = "terra")
r <- rast(f)
plot(r)
filled <- fill_gaps_gauss(r, nsteps = 4, include_list = TRUE)
plot(filled$final)
fill_gaps_gauss <- function(
inrast,
nsteps,
include_list = FALSE
) {
r1 <- rast(ncols = 180, nrows = 180, xmin = 0)
myfilter1 <- focalMat(r1, c(1, 2), "Gauss")
myfilter2 <- focalMat(r1, c(1, 2), "Gauss")
smooth_up_list <- list()
aggregated_list <- list()
aggregated_list[[1]] <- list()
aggregated_list[[1]][[1]] <- inrast
aggregated_list[[1]][[2]] <- !is.na(inrast)
aggregated_list[[1]][[3]] <- inrast*aggregated_list[[1]][[2]]
# Function for weighted smoothing (using product x*x_count)
smooth_weight <- function(prod, x_count, filt) {
smooth_prod <- focal(
prod,
w = filt,
fun = "sum",
na.policy = "all",
na.rm = TRUE
)
smooth_count <- focal(
x_count,
w = filt,
fun = "sum",
na.policy = "all",
na.rm = TRUE
)
out2 <- list()
out2$mean <- smooth_prod / smooth_count
out2$count <- smooth_count
out2$prod <- smooth_prod
return(out2)
}
# Function for weighted aggregation (using product x*x_count)
agg_weight <- function(prod, x_count) {
prod_agg <- terra::aggregate(
prod,
fun = "sum",
na.rm = TRUE
)
count_agg <- terra::aggregate(
x_count,
fun = "sum",
na.rm = TRUE
)
out2 <- list()
out2$mean <- prod_agg / count_agg
out2$count <- count_agg
out2$prod <- prod_agg
return(out2)
}
# Function for projecting maps, weights and products
project_weight <- function(x, targ, dtyp) {
out2 <- list()
# out2$x <- terra::project(
#   x = x[[1]],
#   y = targ,
#   method = "near",
#   datatype = dtyp
# )
out2$x <- NA
out2$x_count <- terra::project(
x = x[[2]] / 4,  # NB
y = targ,
method = "near"
)
out2$prod <- terra::project(
x = x[[3]] / 4,  # NB
y = targ,
method = "near"
)
return(out2)
}
# Function for merging maps and weights
merge_weight <- function(x, y, dtyp) {
emptycells <- is.na(x[[3]])
out2 <- list()
# out2$x <- terra::merge(
#   x = x[[1]],
#   y = y[[1]],
#   wopt = list(datatype = dtyp)
# )
out2$x <- NA
out2$x_count <- terra::ifel(
emptycells,
yes = y[[2]],
no = x[[2]]
)
out2$prod <- terra::ifel(
emptycells,
yes = y[[3]],
no = x[[3]]
)
return(out2)
}
# Stepwise aggregation
for (i in 2:nsteps) {
smoothed_down <- smooth_weight(
prod = aggregated_list[[i - 1]][[3]],
x_count = aggregated_list[[i - 1]][[2]],
myfilter1
)
aggregated_list[[i]] <- agg_weight(
prod = smoothed_down[[3]],
x_count = smoothed_down[[2]]
)
}
smooth_up_list[[nsteps]] <- aggregated_list[[nsteps]]
# Stepwise disaggregation
for (i in (nsteps - 1):1) {
# Disaggregate by 2
splitted <- project_weight(
x = smooth_up_list[[i + 1]],
targ = aggregated_list[[i]][[2]],
dtyp = datatype(inrast)
)
# Merge means and counts
merged <- merge_weight(
x = aggregated_list[[i]],
y = splitted,
dtyp = datatype(inrast)
)
# Weighted smoothing
smooth_up_list[[i]] <- smooth_weight(
prod = merged[[3]],
x_count = merged[[2]],
filt = myfilter2
)
}
final_lyr <- smooth_up_list[[1]][[3]] / smooth_up_list[[1]][[2]]
out <- list()
out$final <- terra::merge(
inrast,
final_lyr,
wopt = list(datatype = datatype(inrast))
)
out$aggregated_list <- aggregated_list
out$smooth_up_list <- smooth_up_list
return(out)
}
f <- system.file("ex/elev.tif", package = "terra")
r <- rast(f)
plot(r)
filled <- fill_gaps_gauss(r, nsteps = 4, include_list = TRUE)
plot(filled$final)
fill_gaps_gauss <- function(
inrast,
nsteps,
include_list = FALSE
) {
r1 <- rast(ncols = 180, nrows = 180, xmin = 0)
myfilter1 <- focalMat(r1, c(1, 2), "Gauss")
myfilter2 <- focalMat(r1, c(1, 2), "Gauss")
smooth_up_list <- list()
aggregated_list <- list()
aggregated_list[[1]] <- list()
aggregated_list[[1]][[1]] <- !is.na(inrast)
aggregated_list[[1]][[2]] <- inrast*aggregated_list[[1]][[2]]
# Function for weighted smoothing (using product x*x_count)
smooth_weight <- function(x, filt) {
out2 <- list()
out2$count <- smooth_count <- focal(
x[[1]],
w = filt,
fun = "sum",
na.policy = "all",
na.rm = TRUE
)
out2$prod <- focal(
x[[2]],
w = filt,
fun = "sum",
na.policy = "all",
na.rm = TRUE
)
return(out2)
}
# Function for weighted aggregation (using product x*x_count)
agg_weight <- function(x) {
out2 <- list()
out2$count <- terra::aggregate(
x[[1]],
fun = "sum",
na.rm = TRUE
)
out2$prod <- terra::aggregate(
x[[2]],
fun = "sum",
na.rm = TRUE
)
return(out2)
}
# Function for projecting counts and products
project_weight <- function(x, targ) {
out2 <- list()
out2$count <- terra::project(
x = x[[1]] / 4,  # NB
y = targ,
method = "near"
)
out2$prod <- terra::project(
x = x[[2]] / 4,  # NB
y = targ,
method = "near"
)
return(out2)
}
# Function for merging counts and products
merge_weight <- function(x, y) {
emptycells <- is.na(x[[2]])
out2 <- list()
out2$count <- terra::ifel(
emptycells,
yes = y[[1]],
no = x[[1]]
)
out2$prod <- terra::ifel(
emptycells,
yes = y[[2]],
no = x[[2]]
)
return(out2)
}
# Stepwise aggregation
for (i in 2:nsteps) {
smoothed_down <- smooth_weight(
x = aggregated_list[[i - 1]],
myfilter1
)
aggregated_list[[i]] <- agg_weight(smoothed_down)
}
smooth_up_list[[nsteps]] <- aggregated_list[[nsteps]]
# Stepwise disaggregation
for (i in (nsteps - 1):1) {
# Disaggregate by 2
splitted <- project_weight(
x = smooth_up_list[[i + 1]],
targ = aggregated_list[[i]][[1]]
)
# Merge means and counts
merged <- merge_weight(
x = aggregated_list[[i]],
y = splitted
)
# Weighted smoothing
smooth_up_list[[i]] <- smooth_weight(merged, myfilter2)
}
final_lyr <- smooth_up_list[[1]][[2]] / smooth_up_list[[1]][[1]]
out <- list()
out$final <- terra::merge(
inrast,
final_lyr,
wopt = list(datatype = datatype(inrast))
)
out$aggregated_list <- aggregated_list
out$smooth_up_list <- smooth_up_list
return(out)
}
f <- system.file("ex/elev.tif", package = "terra")
r <- rast(f)
plot(r)
filled <- fill_gaps_gauss(r, nsteps = 4, include_list = TRUE)
fill_gaps_gauss <- function(
inrast,
nsteps,
include_list = FALSE
) {
r1 <- rast(ncols = 180, nrows = 180, xmin = 0)
myfilter1 <- focalMat(r1, c(1, 2), "Gauss")
myfilter2 <- focalMat(r1, c(1, 2), "Gauss")
smooth_up_list <- list()
aggregated_list <- list()
aggregated_list[[1]] <- list()
aggregated_list[[1]][[1]] <- !is.na(inrast)
aggregated_list[[1]][[2]] <- inrast*aggregated_list[[1]][[1]]
# Function for weighted smoothing (using product x*x_count)
smooth_weight <- function(x, filt) {
out2 <- list()
out2$count <- smooth_count <- focal(
x[[1]],
w = filt,
fun = "sum",
na.policy = "all",
na.rm = TRUE
)
out2$prod <- focal(
x[[2]],
w = filt,
fun = "sum",
na.policy = "all",
na.rm = TRUE
)
return(out2)
}
# Function for weighted aggregation (using product x*x_count)
agg_weight <- function(x) {
out2 <- list()
out2$count <- terra::aggregate(
x[[1]],
fun = "sum",
na.rm = TRUE
)
out2$prod <- terra::aggregate(
x[[2]],
fun = "sum",
na.rm = TRUE
)
return(out2)
}
# Function for projecting counts and products
project_weight <- function(x, targ) {
out2 <- list()
out2$count <- terra::project(
x = x[[1]] / 4,  # NB
y = targ,
method = "near"
)
out2$prod <- terra::project(
x = x[[2]] / 4,  # NB
y = targ,
method = "near"
)
return(out2)
}
# Function for merging counts and products
merge_weight <- function(x, y) {
emptycells <- is.na(x[[2]])
out2 <- list()
out2$count <- terra::ifel(
emptycells,
yes = y[[1]],
no = x[[1]]
)
out2$prod <- terra::ifel(
emptycells,
yes = y[[2]],
no = x[[2]]
)
return(out2)
}
# Stepwise aggregation
for (i in 2:nsteps) {
smoothed_down <- smooth_weight(
x = aggregated_list[[i - 1]],
myfilter1
)
aggregated_list[[i]] <- agg_weight(smoothed_down)
}
smooth_up_list[[nsteps]] <- aggregated_list[[nsteps]]
# Stepwise disaggregation
for (i in (nsteps - 1):1) {
# Disaggregate by 2
splitted <- project_weight(
x = smooth_up_list[[i + 1]],
targ = aggregated_list[[i]][[1]]
)
# Merge means and counts
merged <- merge_weight(
x = aggregated_list[[i]],
y = splitted
)
# Weighted smoothing
smooth_up_list[[i]] <- smooth_weight(merged, myfilter2)
}
final_lyr <- smooth_up_list[[1]][[2]] / smooth_up_list[[1]][[1]]
out <- list()
out$final <- terra::merge(
inrast,
final_lyr,
wopt = list(datatype = datatype(inrast))
)
out$aggregated_list <- aggregated_list
out$smooth_up_list <- smooth_up_list
return(out)
}
f <- system.file("ex/elev.tif", package = "terra")
r <- rast(f)
plot(r)
filled <- fill_gaps_gauss(r, nsteps = 4, include_list = TRUE)
plot(filled$final)
filled <- fill_gaps_gauss(r, nsteps = 5, include_list = TRUE)
plot(filled$final)
filled <- fill_gaps_gauss(r, nsteps = 6, include_list = TRUE)
plot(filled$final)
