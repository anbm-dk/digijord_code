mutate(target = fractions[i]) %>%
mutate(rank = 1:ntop)
}
l %<>% bind_rows() %>%
mutate(
target = factor(
target,
levels = fractions
)
)
l_cat <- cov_cats %>%
mutate(
covariate = name,
category = ifelse(
category == "basic",
scorpan,
category
)
)
l %<>%
left_join(l_cat)
l %<>%
ungroup() %>%
arrange(target, Overall) %>%
mutate(order = row_number())
l$category %<>% as.factor()
# levels(l$category) <- c(
#   "Bare soil",
#   "Spatial position",
#   "Parent materials",
#   "Topography",
#   "S2 time series",
#   "Soil"
# )
catcolors <- l$category %>%
levels() %>%
length() %>%
carto_pal(., "Safe")
names(catcolors) <- levels(l$category)
colScale <- scale_fill_manual(name = "category", values = catcolors)
tiff(
paste0(dir_results, "/importance_test", testn, ".tiff"),
width = 40,
height = 20,
units = "cm",
res = 300
)
l %>%
ggplot(aes(x = order, y = Overall, bg = category)) +
geom_col() +
facet_wrap(
~ target,
ncol = 3,
scales = "free"
) +
# xlim(1, ntop) +
ylim(0, NA) +
coord_flip() +
scale_x_continuous(
breaks = l$order,
labels = l$covariate,
expand = c(0, 0)
) +
colScale
dev.off()
# 10: Make maps for the test area
dir_cov_10km <- dir_dat %>%
paste0(., "/testarea_10km/covariates/")
predfolder <- dir_results %>%
paste0(., "/predictions_testarea/") %T>%
dir.create()
source("f_predict_passna.R")
# Make the maps
uppers <- c(0, 25, 50, 100)
lowers <- c(25, 50, 100, 200)
map_spec <- expand_grid(
fraction_i = 1:6,
interval = 1:4
)
showConnections()
numCores <- 20
cl <- makeCluster(numCores)
clusterEvalQ(
cl,
{
library(terra)
library(caret)
library(xgboost)
library(magrittr)
library(dplyr)
library(tools)
}
)
clusterExport(
cl,
c("uppers",
"lowers",
"map_spec",
"predfolder",
"dir_cov_10km",
"models",
"cov_selected",
"predict_passna",
"dir_dat",
"fractions"
)
)
parSapplyLB(
cl,
1:nrow(map_spec),
function(x) {
tmpfolder <- paste0(dir_dat, "/Temp/")
terraOptions(memfrac = 0.02, tempdir = tmpfolder)
cov_10km <- dir_cov_10km %>%
list.files(full.names = TRUE) %>%
rast() %>%
subset(cov_selected)
outname <- predfolder %>%
paste0(
., "/", fractions[map_spec$fraction_i[x]],
"_depth", map_spec$interval[x],
".tif"
)
predict(
cov_10km,
models[[map_spec$fraction_i[x]]],
fun = predict_passna,
na.rm = FALSE,
const = data.frame(
SOM_removed = 1,
year = 2010,
upper = uppers[map_spec$interval[x]],
lower = lowers[map_spec$interval[x]]
),
n_const = 4,
n_digits = 1,
filename = outname,
overwrite = TRUE
)
return(NA)
}
)
stopCluster(cl)
foreach::registerDoSEQ()
rm(cl)
maps_10_km <- list()
for(i in 1:length(fractions)) {
maps_10_km[[i]] <- c(1:4) %>%
paste0(
predfolder, "/", fractions[i],
"_depth", .,
".tif"
) %>% rast()
names(maps_10_km[[i]]) <- paste0(
fraction_names[i], " ", uppers, " - ", lowers, " cm"
)
}
# SOC depth distribution is very obviously wrong. I will need to fix it.
# I should probably apply a wider spatial filter to reduce the influence of
# the sinks data points.
# Maybe I should use a model to estimate density using covariates, as there is
# a higher concentration in some areas.
# Looking at 10 km maps
library(viridisLite)
library(tidyterra)
try(dev.off())
autoplot(maps_10_km[[1]]) +
scale_fill_gradientn(colours = viridis(100), na.value = NA)
try(dev.off())
lapply(1:6, function(x) {
fname <- paste0(dir_results, "/", fractions[x], "_10km_test", testn, ".tiff")
myplot <- autoplot(maps_10_km[[x]]) +
scale_fill_gradientn(colours = viridis(100), na.value = NA)
tiff(
fname,
width = 16,
height = 14,
units = "cm",
res = 300
)
print(myplot)
try(dev.off())
try(dev.off())
}
)
d_acc <- sapply(
0:199,
function(x) {
mdata <- models[[i]]$pred %>%
bind_cols(models[[i]]$trainingData)
ddat <- mdata %>% filter(
upper < x + 1 & lower > x
)
out <- get_R2w(
select(ddat, pred, obs),
ddat$weights
)
return(out)
}
)
d_wsum <- sapply(
0:199,
function(x) {
mdata <- models[[i]]$pred %>%
bind_cols(models[[i]]$trainingData)
ddat <- mdata %>% filter(
upper < x + 1 & lower > x
)
out <- sum(ddat$weights)
return(out)
}
)
plot(d_acc)
i <- 1
d_acc <- sapply(
0:199,
function(x) {
mdata <- models[[i]]$pred %>%
bind_cols(models[[i]]$trainingData)
ddat <- mdata %>% filter(
upper < x + 1 & lower > x
)
out <- get_R2w(
select(ddat, pred, obs),
ddat$weights
)
return(out)
}
)
d_wsum <- sapply(
0:199,
function(x) {
mdata <- models[[i]]$pred %>%
bind_cols(models[[i]]$trainingData)
ddat <- mdata %>% filter(
upper < x + 1 & lower > x
)
out <- sum(ddat$weights)
return(out)
}
)
plot(d_acc)
plot(d_wsum)
i <- 1
d_acc <- sapply(
0:199,
function(x) {
mdata <- models[[i]]$pred %>%
bind_cols(models[[i]]$trainingData)
ddat <- mdata %>% filter(
upper < x + 1 & lower > x
)
out <- get_RMSEw(
select(ddat, pred, obs),
ddat$weights
)
return(out)
}
)
d_wsum <- sapply(
0:199,
function(x) {
mdata <- models[[i]]$pred %>%
bind_cols(models[[i]]$trainingData)
ddat <- mdata %>% filter(
upper < x + 1 & lower > x
)
out <- sum(ddat$weights)
return(out)
}
)
plot(d_acc)
models[[i]]
i <- 2
d_acc <- sapply(
0:199,
function(x) {
mdata <- models[[i]]$pred %>%
bind_cols(models[[i]]$trainingData)
ddat <- mdata %>% filter(
upper < x + 1 & lower > x
)
out <- get_RMSEw(
select(ddat, pred, obs),
ddat$weights
)
return(out)
}
)
d_wsum <- sapply(
0:199,
function(x) {
mdata <- models[[i]]$pred %>%
bind_cols(models[[i]]$trainingData)
ddat <- mdata %>% filter(
upper < x + 1 & lower > x
)
out <- sum(ddat$weights)
return(out)
}
)
plot(d_acc)
plot(d_wsum)
i <- 3
d_acc <- sapply(
0:199,
function(x) {
mdata <- models[[i]]$pred %>%
bind_cols(models[[i]]$trainingData)
ddat <- mdata %>% filter(
upper < x + 1 & lower > x
)
out <- get_RMSEw(
select(ddat, pred, obs),
ddat$weights
)
return(out)
}
)
d_wsum <- sapply(
0:199,
function(x) {
mdata <- models[[i]]$pred %>%
bind_cols(models[[i]]$trainingData)
ddat <- mdata %>% filter(
upper < x + 1 & lower > x
)
out <- sum(ddat$weights)
return(out)
}
)
plot(d_acc)
plot(d_wsum)
i <- 4
d_acc <- sapply(
0:199,
function(x) {
mdata <- models[[i]]$pred %>%
bind_cols(models[[i]]$trainingData)
ddat <- mdata %>% filter(
upper < x + 1 & lower > x
)
out <- get_RMSEw(
select(ddat, pred, obs),
ddat$weights
)
return(out)
}
)
d_wsum <- sapply(
0:199,
function(x) {
mdata <- models[[i]]$pred %>%
bind_cols(models[[i]]$trainingData)
ddat <- mdata %>% filter(
upper < x + 1 & lower > x
)
out <- sum(ddat$weights)
return(out)
}
)
plot(d_acc)
plot(d_wsum)
i <- 5
d_acc <- sapply(
0:199,
function(x) {
mdata <- models[[i]]$pred %>%
bind_cols(models[[i]]$trainingData)
ddat <- mdata %>% filter(
upper < x + 1 & lower > x
)
out <- get_RMSEw(
select(ddat, pred, obs),
ddat$weights
)
return(out)
}
)
d_wsum <- sapply(
0:199,
function(x) {
mdata <- models[[i]]$pred %>%
bind_cols(models[[i]]$trainingData)
ddat <- mdata %>% filter(
upper < x + 1 & lower > x
)
out <- sum(ddat$weights)
return(out)
}
)
plot(d_acc)
plot(d_wsum)
i <- 6
d_acc <- sapply(
0:199,
function(x) {
mdata <- models[[i]]$pred %>%
bind_cols(models[[i]]$trainingData)
ddat <- mdata %>% filter(
upper < x + 1 & lower > x
)
out <- get_RMSEw(
select(ddat, pred, obs),
ddat$weights
)
return(out)
}
)
d_wsum <- sapply(
0:199,
function(x) {
mdata <- models[[i]]$pred %>%
bind_cols(models[[i]]$trainingData)
ddat <- mdata %>% filter(
upper < x + 1 & lower > x
)
out <- sum(ddat$weights)
return(out)
}
)
plot(d_acc)
plot(d_wsum)
log(1)
log(10)
log(100)
sigma_j
models[[5]]
models[[5]]$finalModel
dens_j
plot(dens_j)
get_dens <- function(datxy, sig) {
dens_out <- ppp(
datxy$UTMX,
datxy$UTMY,
c(441000, 894000),
c(6049000, 6403000)
) %>%
density(
sigma = sig,
at = 'points',
leaveoneout = FALSE
)
attributes(dens_out) <- NULL
return(dens_out)
}
models[[5]]
dens_jk
min(dens_j)
w_depth
w_depth %>% plot()
i <- 6
d_acc <- sapply(
0:199,
function(x) {
mdata <- models[[i]]$pred %>%
bind_cols(models[[i]]$trainingData)
ddat <- mdata %>% filter(
upper < x + 1 & lower > x
)
out <- get_RMSEw(
select(ddat, pred, obs),
ddat$weights
)
return(out)
}
)
d_wsum <- sapply(
0:199,
function(x) {
mdata <- models[[i]]$pred %>%
bind_cols(models[[i]]$trainingData)
ddat <- mdata %>% filter(
upper < x + 1 & lower > x
)
out <- sum(ddat$weights)
return(out)
}
)
plot(d_acc)
plot(d_wsum)
?is.finite
rowSums()
?rowSums
m <- matric(1:4, nrow = 2)
m <- matriz(1:4, nrow = 2)
m <- matrix(1:4, nrow = 2)
m
m[1,1] <- NA
rowSums(m)
m[1,1] <- inf
m[1,1] <- Inf
rowSums(m)
metrics <- rep('RMSEw_log', length(fractions))
metrics
metrics <- rep('RMSEw', length(fractions))
metrics[fractions == "SOC"] <- 'RMSEw_log'
metrics
WeightedSummary_log <- function (
data,
lev = NULL,
model = NULL,
...
) {
out <- numeric()
data[, 1:2] <- log(data[, 1:2])
data <- data[is.finite(rowSums(data)), ]
out[1] <- get_RMSEw(data[, 1:2], data$weights)
out[2] <- get_R2w(data[, 1:2], data$weights)
names(out) <- c('RMSEw_log', 'R2w_log')
return(out)
}
