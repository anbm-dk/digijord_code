paste0(., "SINKS_extr.csv") %>%
read.table(
header = TRUE,
sep = ";",
)
folds <- bind_rows(
dsc_folds,
SEGES_folds,
SINKS_folds
)
names(folds) <- "fold"
extr <- bind_rows(
dsc_extr,
SEGES_extr,
SINKS_extr
)
names(extr)
obs <- cbind(obs, extr, folds)
obs_top <- obs %>%
filter(upper == 0)
cov_c <- extr %>%
names() %>%
paste0(collapse = " + ")
tgrid <- data.frame(
committees = 20,
neighbors = 0
)
n <- 1000
?density
install.packages("spatstat")
library(spatstat)
use_all_points <- FALSE
pts <- ppp(obs$UTMX, obs$UTMY, c(0, 1), c(0, 1))
dens <- density(
pts,
sigma = 250,
at = 'points',
leaveoneout = FALSE,
)
ext(cov)
?ppp
pts <- ppp(
obs$UTMX,
obs$UTMY,
c(441000, 894000),
c(6049000, 6403000)
)
pts <- ppp(
obs_top$UTMX,
obs_top$UTMY,
c(441000, 894000),
c(6049000, 6403000)
)
dens <- density(
pts,
sigma = 250,
at = 'points',
leaveoneout = FALSE,
)
dens
plot(dens)
str(dens)
?vect()
pts_v <- vect(obs_top, geom = c("UTMX", "UTMY"), crs = mycrs)
pts_v$dens <- dens
plot(pts_v, "dens")
pts_v <- obs_top %>%
mutate(
dens = dens,
w = 1 / dens
) %>%
vect(obs_top, geom = c("UTMX", "UTMY"), crs = mycrs)
pts <- ppp(
obs_top$UTMX,
obs_top$UTMY,
c(441000, 894000),
c(6049000, 6403000)
)
dens <- density(
pts,
sigma = 250,
at = 'points',
leaveoneout = FALSE,
)
pts_v <- obs_top %>%
mutate(
density = dens,
w = 1 / dens
) %>%
vect(obs_top, geom = c("UTMX", "UTMY"), crs = mycrs)
pts_v <- obs_top %>%
mutate(
density = dens,
w = 1 / dens
) %>%
vect(
geom = c("UTMX", "UTMY"),
crs = mycrs
)
plot(pts_v, "w")
pts <- ppp(
obs_top$UTMX,
obs_top$UTMY,
c(441000, 894000),
c(6049000, 6403000)
)
dens <- density(
pts,
sigma = 250,
at = 'points',
leaveoneout = FALSE,
)
pts_v <- obs_top %>%
mutate(
density = dens,
w = max(dens) / dens
) %>%
vect(
geom = c("UTMX", "UTMY"),
crs = mycrs
)
plot(pts_v, "w")
pts <- ppp(
obs_top$UTMX,
obs_top$UTMY,
c(441000, 894000),
c(6049000, 6403000)
)
dens <- density(
pts,
sigma = 250,
at = 'points',
leaveoneout = FALSE,
)
pts_v <- obs_top %>%
mutate(
density = dens,
w = min(dens) / dens
) %>%
vect(
geom = c("UTMX", "UTMY"),
crs = mycrs
)
plot(pts_v, "w")
plot(pts_v$w)
mean(pts_v$w)
install.packages("boot")
folds <- bind_rows(
dsc_folds,
SEGES_folds,
SINKS_folds
)
names(folds) <- "fold"
extr <- bind_rows(
dsc_extr,
SEGES_extr,
SINKS_extr
)
obs <- cbind(obs, extr, folds)
obs_top <- obs %>%
filter(upper == 0)
names(obs_top)
obs <- list(dsc, SEGES, SINKS) %>%
vect() %>%
values() %>%
mutate(
logSOC = log(SOC),
logCaCO3 = log(CaCO3)
)
fractions <- c("clay", "silt", "fine_sand", "coarse_sand", "logSOC", "logCaCO3")
bounds_lower <- c(0, 0, 0, 0, NA, NA)
bounds_upper <- c(100, 100, 100, 100, log(100), log(100))
# 7: Make training data
folds <- bind_rows(
dsc_folds,
SEGES_folds,
SINKS_folds
)
names(folds) <- "fold"
extr <- bind_rows(
dsc_extr,
SEGES_extr,
SINKS_extr
)
obs <- cbind(obs, extr, folds)
obs_top <- obs %>%
filter(upper == 0)
# 8: Set up models
# Small random sample for testing
cov_c <- extr %>%
names() %>%
paste0(collapse = " + ")
tgrid <- data.frame(
committees = 20,
neighbors = 0
)
n <- 1000
# Remember to include full dataset in the final model
use_all_points <- FALSE
# Weighted RMSE
RMSEw <- function(d, w)
{
sqe <- w*(d[, 1] - d[, 2])^2
msqe <- sum(sqe)/sum(w)
out <- sqrt(msqe)
return(out)
}
# Weighted R^2
R2w <- function(d, w)
{
require(boot)
out <- boot::corr(d[, 1:2], w)^2
return(out)
}
# Weighted summary function
WeightedSummary <- function(data, lev = NULL, model = NULL, ...)
{
out <- numeric()
# Weighted RMSE
RMSEw <- function(d, w)
{
sqe <- w*(d[, 1] - d[, 2])^2
msqe <- sum(sqe)/sum(w)
out <- sqrt(msqe)
return(out)
}
out[1] <- RMSEw(data[, 1:2], data$weights)
# Weighted R^2
require(boot)
out[2] <- boot::corr(data[, 1:2], data$weights)^2
names(out) <- c('RMSEw', 'R2w')
return(out)
}
models <- list()
for (i in 1:length(fractions))
{
frac <- fractions[i]
print(frac)
formula_i <- paste0(frac, " ~ ", cov_c) %>%
as.formula()
if (use_all_points) {
trdat <- obs_top %>%
filter(is.finite(.data[[frac]]))
} else {
trdat <- obs_top %>%
filter(is.finite(.data[[frac]])) %>%
sample_n(n)
}
# Calculate weights
dens <- ppp(
trdat$UTMX,
trdat$UTMY,
c(441000, 894000),
c(6049000, 6403000)
) %>%
density(
sigma = 250,
at = 'points',
leaveoneout = FALSE
)
trdat %<>%
mutate(
density = dens,
w = min(dens) / dens
)
folds_i <- lapply(
1:10,
function(x) {
out <- trdat %>%
mutate(
is_j = fold != x,
rnum = row_number(),
ind_j = is_j*rnum
) %>%
filter(ind_j != 0) %>%
select(ind_j) %>%
unlist() %>%
unname()
}
)
showConnections()
cl <- makePSOCKcluster(10)
registerDoParallel(cl)
set.seed(1)
models[[i]] <- caret::train(
form = formula_i,
data = trdat,
method = "cubist",
na.action = na.pass,
tuneGrid = tgrid,
trControl = trainControl(
index = folds_i,
savePredictions = "final",
predictionBounds = c(bounds_lower[i], bounds_upper[i]),
summaryFunction = WeightedSummary
),
metric = 'RMSEw',
maximize = FALSE,
weights = trdat$w
)
registerDoSEQ()
rm(cl)
}
names(models) <- fractions
models
models %>% lapply(
function(x) {
varImp(x)
}
)
grep("gw", cov_names)
grep("gw", cov_names, value = TRUE)
grep("gw", cov_names, value = TRUE) %>% setdiff(cov_names)
?setdiff
grep("gw", cov_names, value = TRUE) %>% base::setdiff(., cov_names)
?grep
grep("gw", cov_names, value = TRUE, invert = TRUE)
extr %>%
names() %>%
grep("gw", ., value = TRUE, invert = TRUE) %>%
paste0(collapse = " + ")
models <- list()
for (i in 1:length(fractions))
{
frac <- fractions[i]
print(frac)
if(frac == "clay") {
cov_c_i <- extr %>%
names() %>%
grep(
"gw",
., value = TRUE,
invert = TRUE
) %>%
paste0(collapse = " + ")
formula_i <- paste0(frac, " ~ ", cov_c_i) %>%
as.formula()
} else {
formula_i <- paste0(frac, " ~ ", cov_c) %>%
as.formula()
}
if (use_all_points) {
trdat <- obs_top %>%
filter(is.finite(.data[[frac]]))
} else {
trdat <- obs_top %>%
filter(is.finite(.data[[frac]])) %>%
sample_n(n)
}
# Calculate weights
dens <- ppp(
trdat$UTMX,
trdat$UTMY,
c(441000, 894000),
c(6049000, 6403000)
) %>%
density(
sigma = 250,
at = 'points',
leaveoneout = FALSE
)
trdat %<>%
mutate(
density = dens,
w = min(dens) / dens
)
folds_i <- lapply(
1:10,
function(x) {
out <- trdat %>%
mutate(
is_j = fold != x,
rnum = row_number(),
ind_j = is_j*rnum
) %>%
filter(ind_j != 0) %>%
select(ind_j) %>%
unlist() %>%
unname()
}
)
showConnections()
cl <- makePSOCKcluster(10)
registerDoParallel(cl)
set.seed(1)
models[[i]] <- caret::train(
form = formula_i,
data = trdat,
method = "cubist",
na.action = na.pass,
tuneGrid = tgrid,
trControl = trainControl(
index = folds_i,
savePredictions = "final",
predictionBounds = c(bounds_lower[i], bounds_upper[i]),
summaryFunction = WeightedSummary
),
metric = 'RMSEw',
maximize = FALSE,
weights = trdat$w
)
registerDoSEQ()
rm(cl)
}
names(models) <- fractions
models
models %>% lapply(
function(x) {
varImp(x)
}
)
models %>% lapply(
function(x) {
x %>%
varImp %>%
.$importance %>%
rownames_to_column(var = "covariate") %>%
arrange(-Overall)
}
)
?svae
?save
dir_results <- dir_dat %>%
paste0(., "/results_test_", testn, "/") %T>%
dir.create()
models <- list()
for (i in 1:length(fractions))
{
frac <- fractions[i]
print(frac)
if(frac == "clay") {
cov_c_i <- extr %>%
names() %>%
grep(
"gw",
., value = TRUE,
invert = TRUE
) %>%
paste0(collapse = " + ")
formula_i <- paste0(frac, " ~ ", cov_c_i) %>%
as.formula()
} else {
formula_i <- paste0(frac, " ~ ", cov_c) %>%
as.formula()
}
if (use_all_points) {
trdat <- obs_top %>%
filter(is.finite(.data[[frac]]))
} else {
trdat <- obs_top %>%
filter(is.finite(.data[[frac]])) %>%
sample_n(n)
}
# Calculate weights
dens <- ppp(
trdat$UTMX,
trdat$UTMY,
c(441000, 894000),
c(6049000, 6403000)
) %>%
density(
sigma = 250,
at = 'points',
leaveoneout = FALSE
)
trdat %<>%
mutate(
density = dens,
w = min(dens) / dens
)
folds_i <- lapply(
1:10,
function(x) {
out <- trdat %>%
mutate(
is_j = fold != x,
rnum = row_number(),
ind_j = is_j*rnum
) %>%
filter(ind_j != 0) %>%
select(ind_j) %>%
unlist() %>%
unname()
}
)
showConnections()
cl <- makePSOCKcluster(10)
registerDoParallel(cl)
set.seed(1)
models[[i]] <- caret::train(
form = formula_i,
data = trdat,
method = "cubist",
na.action = na.pass,
tuneGrid = tgrid,
trControl = trainControl(
index = folds_i,
savePredictions = "final",
predictionBounds = c(bounds_lower[i], bounds_upper[i]),
summaryFunction = WeightedSummary
),
metric = 'RMSEw',
maximize = FALSE,
weights = trdat$w
)
registerDoSEQ()
rm(cl)
saveRDS(
models[[i]],
paste0(dir_results, "/model_", frac, ".rds")
)
}
