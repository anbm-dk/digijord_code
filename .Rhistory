seed = 321  # Random seed for model training
)
stopCluster(cl)
foreach::registerDoSEQ()
rm(cl)
showConnections()
showConnections()
# Set up model
source("f_optimize_xgboost.R")
source("f_weighted_summaries.R")
model_DC <- optimize_xgboost(
target = "DCfac",  # character vector (length 1), target variable.
cov_names = cov_DC_names,  # Character vector, covariate names,
data = trdat_DC, # data frame, input data
bounds_bayes = bounds_DC, # named list with bounds for bayesian opt.
bounds_pred = c(FALSE, FALSE), # numeric, length 2, bounds for predicted values
cores = 19, # number cores for parallelization
trgrid = tgrid, # data frame with tuning parameters to be tested in basic model
folds = folds_DC, # list with indices, folds for cross validation
sumfun = WeightedSummary_DC, # summary function for accuracy assessment
metric = "OAw", # character, length 1, name of evaluation metric
max_metric = TRUE, # logical, should the evaluation metric be maximized
weights = trdat_DC$w, # numeric, weights for model training and evaluation
trees_per_round = 10, # numeric, length 1, number of trees that xgboost should train in each round
obj_xgb = "multi:softprob", # character, length 1, objective function for xgboost
colsample_bylevel_basic = 0.75, # numeric, colsample_bylevel for basic model
cov_keep = NULL, # Character vector, covariates that should always be present
final_round_mult = 10,  # Multiplier for the number of rounds in the final model
seed = 321  # Random seed for model training
)
as.numeric(obs_DC)
obs_DC %>% as.matrix()
obs_DC %>% as.matrix() %>% as.numeric()
?as.matrix
trdat_DC %>% as.matrix() %>% as.numeric()
trdat_DC %>% as.matrix()
?lapply(list, function)
?lapply
?apply
?as.numeric
foreach::registerDoSEQ()
showConnections()
foreach::registerDoSEQ()
showConnections()
source("f_optimize_xgboost.R")
source("f_weighted_summaries.R")
model_DCfac <- optimize_xgboost(
target = "DCfac",  # character vector (length 1), target variable.
cov_names = cov_DC_names,  # Character vector, covariate names,
data = trdat_DC, # data frame, input data
bounds_bayes = bounds_DC, # named list with bounds for bayesian opt.
bounds_pred = c(FALSE, FALSE), # numeric, length 2, bounds for predicted values
cores = 19, # number cores for parallelization
trgrid = tgrid, # data frame with tuning parameters to be tested in basic model
folds = folds_DC, # list with indices, folds for cross validation
sumfun = WeightedSummary_DC, # summary function for accuracy assessment
metric = "OAw", # character, length 1, name of evaluation metric
max_metric = TRUE, # logical, should the evaluation metric be maximized
weights = trdat_DC$w, # numeric, weights for model training and evaluation
trees_per_round = 10, # numeric, length 1, number of trees that xgboost should train in each round
obj_xgb = "multi:softprob", # character, length 1, objective function for xgboost
colsample_bylevel_basic = 0.75, # numeric, colsample_bylevel for basic model
cov_keep = NULL, # Character vector, covariates that should always be present
final_round_mult = 10,  # Multiplier for the number of rounds in the final model
seed = 321  # Random seed for model training
)
?as.data.frame
foreach::registerDoSEQ()
showConnections()
source("f_optimize_xgboost.R")
source("f_weighted_summaries.R")
source("f_optimize_xgboost.R")
source("f_weighted_summaries.R")
model_DCfac <- optimize_xgboost(
target = "DCfac",  # character vector (length 1), target variable.
cov_names = cov_DC_names,  # Character vector, covariate names,
data = trdat_DC, # data frame, input data
bounds_bayes = bounds_DC, # named list with bounds for bayesian opt.
bounds_pred = c(FALSE, FALSE), # numeric, length 2, bounds for predicted values
cores = 19, # number cores for parallelization
trgrid = tgrid, # data frame with tuning parameters to be tested in basic model
folds = folds_DC, # list with indices, folds for cross validation
sumfun = WeightedSummary_DC, # summary function for accuracy assessment
metric = "OAw", # character, length 1, name of evaluation metric
max_metric = TRUE, # logical, should the evaluation metric be maximized
weights = trdat_DC$w, # numeric, weights for model training and evaluation
trees_per_round = 10, # numeric, length 1, number of trees that xgboost should train in each round
obj_xgb = "multi:softprob", # character, length 1, objective function for xgboost
colsample_bylevel_basic = 0.75, # numeric, colsample_bylevel for basic model
cov_keep = NULL, # Character vector, covariates that should always be present
final_round_mult = 10,  # Multiplier for the number of rounds in the final model
seed = 321  # Random seed for model training
)
trdat_DC
trdat_DC %>% str()
trdat_DC$DCfac
?train
?apply
source("f_optimize_xgboost.R")
source("f_weighted_summaries.R")
foreach::registerDoSEQ()
showConnections()
source("f_optimize_xgboost.R")
source("f_weighted_summaries.R")
foreach::registerDoSEQ()
showConnections()
model_DCfac <- optimize_xgboost(
target = "DCfac",  # character vector (length 1), target variable.
cov_names = cov_DC_names,  # Character vector, covariate names,
data = trdat_DC, # data frame, input data
bounds_bayes = bounds_DC, # named list with bounds for bayesian opt.
bounds_pred = c(FALSE, FALSE), # numeric, length 2, bounds for predicted values
cores = 19, # number cores for parallelization
trgrid = tgrid, # data frame with tuning parameters to be tested in basic model
folds = folds_DC, # list with indices, folds for cross validation
sumfun = WeightedSummary_DC, # summary function for accuracy assessment
metric = "OAw", # character, length 1, name of evaluation metric
max_metric = TRUE, # logical, should the evaluation metric be maximized
weights = trdat_DC$w, # numeric, weights for model training and evaluation
trees_per_round = 10, # numeric, length 1, number of trees that xgboost should train in each round
obj_xgb = "multi:softprob", # character, length 1, objective function for xgboost
colsample_bylevel_basic = 0.75, # numeric, colsample_bylevel for basic model
cov_keep = NULL, # Character vector, covariates that should always be present
final_round_mult = 10,  # Multiplier for the number of rounds in the final model
seed = 321,  # Random seed for model training,
classprob = TRUE
)
foreach::registerDoSEQ()
showConnections()
foreach::registerDoSEQ()
showConnections()
source("f_optimize_xgboost.R")
source("f_weighted_summaries.R")
model_DCfac <- optimize_xgboost(
target = "DCfac",  # character vector (length 1), target variable.
cov_names = cov_DC_names,  # Character vector, covariate names,
data = trdat_DC, # data frame, input data
bounds_bayes = bounds_DC, # named list with bounds for bayesian opt.
bounds_pred = c(FALSE, FALSE), # numeric, length 2, bounds for predicted values
cores = 19, # number cores for parallelization
trgrid = tgrid, # data frame with tuning parameters to be tested in basic model
folds = folds_DC, # list with indices, folds for cross validation
sumfun = WeightedSummary_DCfac, # summary function for accuracy assessment
metric = "OAw", # character, length 1, name of evaluation metric
max_metric = TRUE, # logical, should the evaluation metric be maximized
weights = trdat_DC$w, # numeric, weights for model training and evaluation
trees_per_round = 10, # numeric, length 1, number of trees that xgboost should train in each round
obj_xgb = "multi:softprob", # character, length 1, objective function for xgboost
colsample_bylevel_basic = 0.75, # numeric, colsample_bylevel for basic model
cov_keep = NULL, # Character vector, covariates that should always be present
final_round_mult = 10,  # Multiplier for the number of rounds in the final model
seed = 321,  # Random seed for model training,
classprob = TRUE
)
source("f_optimize_xgboost.R")
source("f_weighted_summaries.R")
foreach::registerDoSEQ()
showConnections()
foreach::registerDoSEQ()
showConnections()
model_DCfac <- optimize_xgboost(
target = "DCfac",  # character vector (length 1), target variable.
cov_names = cov_DC_names,  # Character vector, covariate names,
data = trdat_DC, # data frame, input data
bounds_bayes = bounds_DC, # named list with bounds for bayesian opt.
bounds_pred = c(FALSE, FALSE), # numeric, length 2, bounds for predicted values
cores = 19, # number cores for parallelization
trgrid = tgrid, # data frame with tuning parameters to be tested in basic model
folds = folds_DC, # list with indices, folds for cross validation
sumfun = WeightedSummary_DCfac, # summary function for accuracy assessment
metric = "OAw", # character, length 1, name of evaluation metric
max_metric = TRUE, # logical, should the evaluation metric be maximized
weights = trdat_DC$w, # numeric, weights for model training and evaluation
trees_per_round = 10, # numeric, length 1, number of trees that xgboost should train in each round
obj_xgb = "multi:softprob", # character, length 1, objective function for xgboost
colsample_bylevel_basic = 0.75, # numeric, colsample_bylevel for basic model
cov_keep = NULL, # Character vector, covariates that should always be present
final_round_mult = 10,  # Multiplier for the number of rounds in the final model
seed = 321,  # Random seed for model training,
classprob = TRUE
)
model_DCfac
model_DC
model_DCfac$model %>% varImp()
model_DCfac
View(WeightedSummary)
fractions_alt <- c("clay", "silt", "fine_sand", "coarse_sand", "SOC", "CaCO3")
fractions <- fractions_alt
dir_cov_10km <- dir_dat %>%
paste0(., "/testarea_10km/covariates/")
predfolder <- dir_results %>%
paste0(., "/predictions_testarea/")
source("f_predict_passna.R")
maps_10_km <- list()
breaks <- c(0, 30, 60, 100, 200)
uppers <- breaks %>% rev() %>% .[-1] %>% rev()
lowers <- breaks %>% .[-1]
maps_10_km <- list()
for (i in 1:length(fractions)) {
maps_10_km[[i]] <- c(1:4) %>%
paste0(
predfolder, "/", fractions[i],
"_depth", .,
".tif"
) %>%
rast()
names(maps_10_km[[i]]) <- paste0(
fraction_names[i], ", ", uppers, " - ", lowers, " cm"
)
}
maps_10_km <- list()
for (i in 1:length(fractions)) {
maps_10_km[[i]] <- c(1:4) %>%
paste0(
predfolder, "/", fractions[i],
"_depth", .,
".tif"
) %>%
rast()
# names(maps_10_km[[i]]) <- paste0(
#   fraction_names[i], ", ", uppers, " - ", lowers, " cm"
# )
}
maps_10_km
maps_10_km_mineral_fin <- lapply(
1:4, function(i) {
mineral_raw <- c(
maps_10_km[[1]][[i]],
maps_10_km[[2]][[i]],
maps_10_km[[3]][[i]],
maps_10_km[[4]][[i]]
)
mineral_sum_r <- mineral_raw %>% sum()
mineral_final <- mineral_raw*100 / mineral_sum_r
mineral_final %<>% round(., digits = 1)
return(mineral_final)
}
)
maps_10_km_mineral_fin_frac <- lapply(
1:4, function(x) {
out <- c(
maps_10_km_mineral_fin[[1]][[x]],
maps_10_km_mineral_fin[[2]][[x]],
maps_10_km_mineral_fin[[3]][[x]],
maps_10_km_mineral_fin[[4]][[x]]
)
}
)
for (i in 1:length(maps_10_km_mineral_fin_frac)) {
maps_10_km[[i]] <- maps_10_km_mineral_fin_frac[[i]]
}
maps_10_km
c(maps_10_km)
rast(maps_10_km)
texture_10km <- rast(maps_10_km)
tex_pred
names(texture_10km)
names(tex_pred)
max_char <- breaks %>%
as.character() %>%
nchar() %>%
max()
breaks_chr <- breaks %>%
str_pad(
.,
max_char,
pad = "0"
)
paste0(fraction_names_underscore, "_", breaks_chr[1:4], "_", breaks_chr[2:5], "_cm")
max_char <- breaks %>%
as.character() %>%
nchar() %>%
max()
breaks_chr <- breaks %>%
str_pad(
.,
max_char,
pad = "0"
)
library(stringr)
max_char <- breaks %>%
as.character() %>%
nchar() %>%
max()
breaks_chr <- breaks %>%
str_pad(
.,
max_char,
pad = "0"
)
paste0(fraction_names_underscore, "_", breaks_chr[1:4], "_", breaks_chr[2:5], "_cm")
?paste0
depth_int_chr <- paste0(breaks_chr[1:4], "_", breaks_chr[2:5], "_cm")
paste0(fraction_names_underscore, "_", depth_int_chr)
?paste0
sapply(depth_int_chr, function(x) paste0(fraction_names_underscore, "_", x))
sapply(depth_int_chr, function(x) paste0(fraction_names_underscore, "_", x), simplify = TRUE)
sapply(depth_int_chr, function(x) paste0(fraction_names_underscore, "_", x)) %>% as.vector()
sapply(fraction_names_underscore, function(x) paste0(x, "_", depth_int_chr)) %>% as.vector()
texture_10km <- rast(maps_10_km)
names(texture_10km) <- sapply(
fraction_names_underscore,
function(x) paste0(x, "_", depth_int_chr)
) %>% as.vector()
cov_10km <- dir_cov_10km %>%
list.files(full.names = TRUE) %>%
rast() %>%
subset(cov_selected)
cov_10km_DC <- c(cov_10km, texture_10km)
cov_10km_DC <- c(cov_10km, texture_10km) %>%
subset(., colnames(varImp(model_DCfac$model)))
?subset
cov_10km_DC <- c(cov_10km, texture_10km) %>%
terra::subset(., colnames(varImp(model_DCfac$model)))
c(cov_10km, texture_10km)
c(cov_10km, texture_10km) %>% names()
cov_10km_DC <- c(cov_10km, texture_10km) %>%
terra::subset(., rownames(varImp(model_DCfac$model)))
rownames(varImp(model_DCfac$model))
rownames(varImp(model_DCfac$model)$importance)
cov_10km_DC <- c(cov_10km, texture_10km) %>%
terra::subset(., rownames(varImp(model_DCfac$model)$importance))
cov_10km_DC
pred_DC <- predict(
cov_10km_DC,
model_DCfac,
fun = predict_passna,
na.rm = FALSE,
const = data.frame(
dummy = NA
),
n_const = 0,
n_digits = 1
# ,
# filename = outname,
# overwrite = TRUE
)
pred_DC <- predict(
cov_10km_DC,
model_DCfac$model,
fun = predict_passna,
na.rm = FALSE,
const = data.frame(
dummy = NA
),
n_const = 0,
n_digits = 1
# ,
# filename = outname,
# overwrite = TRUE
)
pred_DC
plot(pred_DC)
?predict
?predict.train
?predict
?predict.train
pred_DC_prob <- predict(
cov_10km_DC,
model_DCfac$model,
fun = predict_passna,
na.rm = FALSE,
const = data.frame(
dummy = NA
),
n_const = 0,
n_digits = 0,
type = "prob"
# ,
# filename = outname,
# overwrite = TRUE
)
pred_DC_prob <- predict(
cov_10km_DC,
model_DCfac$model,
fun = predict_passna,
na.rm = FALSE,
const = data.frame(
dummy = NA
),
n_const = 0,
n_digits = 2,
type = "prob"
# ,
# filename = outname,
# overwrite = TRUE
)
model_DCfac
model_DCfac$model
model_DCfac$model$levels
model_DCfac$model$levels %>% length()
source("f_predict_passna.R")
pred_DC_prob <- predict(
cov_10km_DC,
model_DCfac$model,
fun = predict_passna_,
na.rm = FALSE,
const = data.frame(
dummy = NA
),
n_const = 0,
n_digits = 2,
type = "prob"
# ,
# filename = outname,
# overwrite = TRUE
)
pred_DC_prob <- predict(
cov_10km_DC,
model_DCfac$model,
fun = predict_passna_prob,
na.rm = FALSE,
const = data.frame(
dummy = NA
),
n_const = 0,
n_digits = 2,
type = "prob"
# ,
# filename = outname,
# overwrite = TRUE
)
pred_DC_prob <- predict(
cov_10km_DC,
model_DCfac$model,
fun = predict_passna_prob,
na.rm = FALSE,
const = data.frame(
dummy = NA
),
n_const = 0,
n_digits = 2,
# ,
# filename = outname,
# overwrite = TRUE
)
pred_DC_prob
plot(pred_DC_prob)
predict(model_DCfac, trdat_DC)
predict(model_DCfac$model, trdat_DC)
predict(model_DCfac$model, trdat_DC, type = "prob")
predict(model_DCfac$model, trdat_DC, type = "prob") %>% as.matrix()
predict_passna_prob(model_DCfac, trdat_DC, n_digits = 2)
predict_passna_prob(model_DCfac$model, trdat_DC, n_digits = 2)
predict_passna_prob(model_DCfac$model, trdat_DC, n_digits = NULL)
source("f_predict_passna.R")
predict_passna_prob(model_DCfac$model, trdat_DC, n_digits = NULL)
source("f_predict_passna.R")
predict_passna_prob(model_DCfac$model, trdat_DC, n_digits = NULL)
predict_passna_prob(model_DCfac$model, trdat_DC, n_digits = 2)
pred_DC_prob <- predict(
cov_10km_DC,
model_DCfac$model,
fun = predict_passna_prob,
na.rm = FALSE,
const = data.frame(
dummy = NA
),
n_const = 0,
n_digits = 2
# ,
# filename = outname,
# overwrite = TRUE
)
plot(pred_DC_prob)
pred_DC_mean <- app(
pred_DC_prob,
function(x) {
out <- stats::weighted.mean(1:5, x, na.rm = TRUE)
return(out)
}
)
plot(dc_mean)
plot(pred_DC_mean)
pred_DC_median <- app(
pred_DC_prob,
function(x) {
out <- spatstat::weighted.median(1:5, x, na.rm = TRUE)
return(out)
}
)
pred_DC_median <- app(
pred_DC_prob,
function(x) {
out <- weighted.median(1:5, x, na.rm = TRUE)
return(out)
}
)
plot(pred_DC, col = cividis(5))
plot(pred_DC, col = rev(cividis(5)))
plot(pred_DC_prob)
plot(pred_DC_prob, col = viridis(100))
plot(pred_DC_mean, col = rev(cividis(100)))
plot(pred_DC, col = rev(cividis(100)))
plot(pred_DC_median, col = rev(cividis(100)))
plot(pred_DC, col = rev(cividis(100)))
?weighted.mean
?weighted.mean
?weighted.median
pred_DC_median <- app(
pred_DC_prob,
function(x) {
out <- weighted.median(1:5, x, na.rm = TRUE, type = 4)
return(out)
}
)
plot(pred_DC_median, col = rev(cividis(100)))
plot(pred_DC_mean, col = rev(cividis(100)))
plot(pred_DC_median, col = rev(cividis(100)))
plot(pred_DC, col = rev(cividis(100)))
plot(pred_DC_mean, col = rev(cividis(100)))
plot(pred_DC_median, col = rev(cividis(100)))
