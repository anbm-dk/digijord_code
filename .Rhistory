library(tools)
}
)
clusterExport(
cl,
c("uppers",
"lowers",
"map_spec",
"predfolder",
"dir_cov_10km",
"models",
"cov_selected",
"predict_passna",
"dir_dat",
"fractions"
)
)
parSapplyLB(
cl,
1:nrow(map_spec),
function(x) {
tmpfolder <- paste0(dir_dat, "/Temp/")
terraOptions(memfrac = 0.02, tempdir = tmpfolder)
cov_10km <- dir_cov_10km %>%
list.files(full.names = TRUE) %>%
rast() %>%
subset(cov_selected)
outname <- predfolder %>%
paste0(
., "/", fractions[map_spec$fraction_i[x]],
"_depth", map_spec$interval[x],
".tif"
)
predict(
cov_10km,
models[[map_spec$fraction_i[x]]],
fun = predict_passna,
na.rm = FALSE,
const = data.frame(
SOM_removed = 1,
year = 2010,
upper = uppers[map_spec$interval[x]],
lower = lowers[map_spec$interval[x]]
),
n_const = 4,
n_digits = 1,
filename = outname,
overwrite = TRUE
)
return(NA)
}
)
stopCluster(cl)
foreach::registerDoSEQ()
rm(cl)
maps_10_km <- list()
for(i in 1:length(fractions)) {
maps_10_km[[i]] <- c(1:4) %>%
paste0(
predfolder, "/", fractions[i],
"_depth", .,
".tif"
) %>% rast()
names(maps_10_km[[i]]) <- paste0(
fraction_names[i], ", ", uppers, " - ", lowers, " cm"
)
}
# SOC depth distribution is very obviously wrong. I will need to fix it. (ok)
# Using a separate density for wetlands fixes this issue.
# Ideally, I should use the extent of the central wetlands, which is the survey
# area for the SINKS dataset-
# Figures for 10 km maps
library(viridisLite)
library(tidyterra)
try(dev.off())
lapply(1:6, function(x) {
fname <- paste0(dir_results, "/", fractions[x], "_10km_test", testn, ".tiff")
myplot <- autoplot(maps_10_km[[x]]) +
scale_fill_gradientn(colours = viridis(100), na.value = NA)
tiff(
fname,
width = 16,
height = 14,
units = "cm",
res = 300
)
print(myplot)
try(dev.off())
try(dev.off())
}
)
# maps_10km_s2 <- c(maps_10km[[1]], maps_10km[[2]], maps_10km[[3]], exp(maps_10km[[5]])/0.568, exp(maps_10km[[6]]))
source("f_classify_soil_JB.R")
maps_10km_jb <- lapply(
1:length(uppers),
function(x) {
maps_10_km_s2 <- c(
maps_10_km[[1]][[x]],
maps_10_km[[2]][[x]],
maps_10_km[[3]][[x]],
maps_10_km[[5]][[x]]/0.568,
maps_10_km[[6]][[x]]
)
names(maps_10_km_s2) <- c("clay", "silt", "sand_f", "SOM", "CaCO3")
out <- lapp(maps_10_km_s2, classify_soil_JB)
return(out)
}
) %>%
rast()
levels(maps_10km_jb) <- rep(
list(
data.frame(
id = 1:12,
Class = paste0("JB", 1:12)
)
),
nlyr(maps_10km_jb)
)
names(maps_10km_jb) <- paste0("JB class, ", uppers, " - ", lowers, " cm")
myrgb <- col2rgb(mycolors)
tsp <- as.TSP(dist(t(myrgb)))
set.seed(1)
sol <- solve_TSP(tsp, control = list(repetitions = 1e3))
ordered_cols <- mycolors[sol]
classes_in_maps <- values(maps_10km_jb) %>%
unlist() %>%
matrix(ncol = 1) %>%
unique() %>%
sort()
cols_in_maps <- ordered_cols[classes_in_maps]
plot_jb <- autoplot(maps_10km_jb) +
scale_fill_discrete(type = cols_in_maps)
tiff(
paste0(dir_results, "/JB_test_", testn, ".tiff"),
width = 15,
height = 10,
units = "cm",
res = 300
)
print(plot_jb)
dev.off()
# END
trdat
trdat2 <- trdat
trdat2 <- trdat
trdat2 %<>% mutate(
thickness = lower - upper
)
int_i <- c(0, 10)
trdat2
trdat2 %<>% mutate(
thickness = lower - upper,
upper_int = case_when(
upper >= int_i[1] & upper <= int_i[2] ~ upper,
upper < int_i[1] & lower > int_i[1] ~ int_i[1],
.default = NA
)
)
trdat2
int_i <- c(5, 15)
trdat2 <- trdat %>% filter(
upper < int_i[2] & lower > int_i[1]
)
trdat2
int_i <- c(5, 15)
trdat2 <- trdat %>% filter(
upper < int_i[2] & lower > int_i[1]
)
trdat2 %>%
mutate(
thickness = lower - upper,
upper_int = case_when(
upper > int_i[1] ~ upper,
.default = int_i[1]
),
lower_int = case_when(
lower < int_i[2] ~ lower,
.default = int_i[2]
),
cm_int = lower_int - upper_int
)
int_i <- c(15, 25)
trdat2 <- trdat %>% filter(
upper < int_i[2] & lower > int_i[1]
)
trdat2 %>%
mutate(
thickness = lower - upper,
upper_int = case_when(
upper > int_i[1] ~ upper,
.default = int_i[1]
),
lower_int = case_when(
lower < int_i[2] ~ lower,
.default = int_i[2]
),
cm_int = lower_int - upper_int
)
int_i <- c(10, 40)
trdat2 <- trdat %>% filter(
upper < int_i[2] & lower > int_i[1]
)
trdat2 %>%
mutate(
thickness = lower - upper,
upper_int = case_when(
upper > int_i[1] ~ upper,
.default = int_i[1]
),
lower_int = case_when(
lower < int_i[2] ~ lower,
.default = int_i[2]
),
cm_int = lower_int - upper_int
)
trdat2 %<>%
mutate(
thickness = lower - upper,
upper_int = case_when(
upper > int_i[1] ~ upper,
.default = int_i[1]
),
lower_int = case_when(
lower < int_i[2] ~ lower,
.default = int_i[2]
),
cm_int = lower_int - upper_int
)
plot(trdat2$cm_int)
plot(trdat2$cm_int / trdat2$thickness)
?summarise.SpatVector
?sum
mdata
depths_acc <- c(0:200)
d_out <- list()
# This operation is somewhat slow
# Also calculate statistics by depth for the observations
for (i in 1:length(fractions)) {
mdata <- models[[i]]$pred %>%
bind_cols(models[[i]]$trainingData)
d_out[[i]] <- lapply(
depths_acc,
function(x) {
ddat <- mdata %>%
filter(
upper < x + 10 & lower > x - 10
) %>%
mutate(
thickness = lower - upper,
upper_int = case_when(
upper > x - 10 ~ upper,
.default = x - 10
),
lower_int = case_when(
lower < x + 10 ~ lower,
.default = x + 10
),
cm_int = lower_int - upper_int,
cm_w_int = case_when(
thickness == 0 ~ 1,
.default = cm_int / thickness
),
combined_weights = cm_w_int*weights
)
out <- data.frame(
Fraction = fractions[i],
Depth = x,
RMSEw = get_RMSEw(
select(ddat, pred, obs),
ddat$weights
),
R2w = get_R2w(
select(ddat, pred, obs),
ddat$weights
),
Weights = sum(ddat$combined_weights)
)
return(out)
}
) %>% bind_rows()
}
d_out %<>%
bind_rows() %>%
mutate(
Fraction = factor(Fraction, levels = fractions, labels = fraction_names)
)
tiff(
paste0(dir_results, "/depth_RMSEw_test_", testn, ".tiff"),
width = 16,
height = 10,
units = "cm",
res = 300
)
d_out %>%
ggplot(aes(x = RMSEw, y = Depth)) +
facet_wrap(~ Fraction, nrow = 1, scales = "free_x") +
geom_path() +
scale_y_reverse(expand = c(0, 0))
try(dev.off())
try(dev.off())
tiff(
paste0(dir_results, "/depth_R2w_test_", testn, ".tiff"),
width = 16,
height = 10,
units = "cm",
res = 300
)
d_out %>%
ggplot(aes(x = R2w, y = Depth)) +
facet_wrap(~ Fraction, nrow = 1, scales = "free_x") +
geom_path() +
scale_y_reverse(expand = c(0, 0))
try(dev.off())
try(dev.off())
tiff(
paste0(dir_results, "/depth_weights_test_", testn, ".tiff"),
width = 16,
height = 10,
units = "cm",
res = 300
)
d_out %>%
ggplot(aes(x = Weights, y = Depth)) +
facet_wrap(~ Fraction, nrow = 1, scales = "free_x") +
geom_path() +
scale_y_reverse(expand = c(0, 0))
try(dev.off())
try(dev.off())
for (i in 1:length(fractions)) {
mdata <- models[[i]]$pred %>%
bind_cols(models[[i]]$trainingData)
d_out[[i]] <- lapply(
depths_acc,
function(x) {
ddat <- mdata %>%
filter(
upper < x + 10 & lower > x - 10
) %>%
mutate(
thickness = lower - upper,
upper_int = case_when(
upper > x - 10 ~ upper,
.default = x - 10
),
lower_int = case_when(
lower < x + 10 ~ lower,
.default = x + 10
),
cm_int = lower_int - upper_int,
cm_w_int = case_when(
thickness == 0 ~ 1,
.default = cm_int / thickness
),
combined_weights = cm_w_int*weights
)
out <- data.frame(
Fraction = fractions[i],
Depth = x,
RMSEw = get_RMSEw(
select(ddat, pred, obs),
ddat$combined_weights
),
R2w = get_R2w(
select(ddat, pred, obs),
ddat$combined_weights
),
Weights = sum(ddat$combined_weights) / mean(cm_w_int)
)
return(out)
}
) %>% bind_rows()
}
for (i in 1:length(fractions)) {
mdata <- models[[i]]$pred %>%
bind_cols(models[[i]]$trainingData)
d_out[[i]] <- lapply(
depths_acc,
function(x) {
ddat <- mdata %>%
filter(
upper < x + 10 & lower > x - 10
) %>%
mutate(
thickness = lower - upper,
upper_int = case_when(
upper > x - 10 ~ upper,
.default = x - 10
),
lower_int = case_when(
lower < x + 10 ~ lower,
.default = x + 10
),
cm_int = lower_int - upper_int,
cm_w_int = case_when(
thickness == 0 ~ 1,
.default = cm_int / thickness
),
combined_weights = cm_w_int*weights
)
out <- data.frame(
Fraction = fractions[i],
Depth = x,
RMSEw = get_RMSEw(
select(ddat, pred, obs),
ddat$combined_weights
),
R2w = get_R2w(
select(ddat, pred, obs),
ddat$combined_weights
),
Weights = sum(ddat$combined_weights) / mean(ddat$cm_w_int)
)
return(out)
}
) %>% bind_rows()
}
depths_acc <- c(0:200)
d_out <- list()
# This operation is somewhat slow
# Also calculate statistics by depth for the observations
for (i in 1:length(fractions)) {
mdata <- models[[i]]$pred %>%
bind_cols(models[[i]]$trainingData)
d_out[[i]] <- lapply(
depths_acc,
function(x) {
ddat <- mdata %>%
filter(
upper < x + 10 & lower > x - 10
) %>%
mutate(
thickness = lower - upper,
upper_int = case_when(
upper > x - 10 ~ upper,
.default = x - 10
),
lower_int = case_when(
lower < x + 10 ~ lower,
.default = x + 10
),
cm_int = lower_int - upper_int,
cm_w_int = case_when(
thickness == 0 ~ 1,
.default = cm_int / thickness
),
combined_weights = cm_w_int*weights
)
out <- data.frame(
Fraction = fractions[i],
Depth = x,
RMSEw = get_RMSEw(
select(ddat, pred, obs),
ddat$combined_weights
),
R2w = get_R2w(
select(ddat, pred, obs),
ddat$combined_weights
),
Weights = sum(ddat$combined_weights) / mean(ddat$cm_w_int)
)
return(out)
}
) %>% bind_rows()
}
d_out %<>%
bind_rows() %>%
mutate(
Fraction = factor(Fraction, levels = fractions, labels = fraction_names)
)
tiff(
paste0(dir_results, "/depth_RMSEw_test_", testn, ".tiff"),
width = 16,
height = 10,
units = "cm",
res = 300
)
d_out %>%
ggplot(aes(x = RMSEw, y = Depth)) +
facet_wrap(~ Fraction, nrow = 1, scales = "free_x") +
geom_path() +
scale_y_reverse(expand = c(0, 0))
try(dev.off())
try(dev.off())
tiff(
paste0(dir_results, "/depth_R2w_test_", testn, ".tiff"),
width = 16,
height = 10,
units = "cm",
res = 300
)
d_out %>%
ggplot(aes(x = R2w, y = Depth)) +
facet_wrap(~ Fraction, nrow = 1, scales = "free_x") +
geom_path() +
scale_y_reverse(expand = c(0, 0))
try(dev.off())
try(dev.off())
tiff(
paste0(dir_results, "/depth_weights_test_", testn, ".tiff"),
width = 16,
height = 10,
units = "cm",
res = 300
)
d_out %>%
ggplot(aes(x = Weights, y = Depth)) +
facet_wrap(~ Fraction, nrow = 1, scales = "free_x") +
geom_path() +
scale_y_reverse(expand = c(0, 0))
try(dev.off())
try(dev.off())
xgb.get.config()
