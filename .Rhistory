) %>%
vect(
geom = c("UTMX", "UTMY"),
crs = mycrs,
keepgeom = TRUE
)
# 3: Load folds
dir_folds <- dir_dat %>%
paste0(., "/folds/")
dsc_folds <- dir_folds %>%
paste0(., "dsc_folds.csv") %>%
read.table(
header = TRUE,
sep = ";",
)
SEGES_folds <- dir_folds %>%
paste0(., "SEGES_folds.csv") %>%
read.table(
header = TRUE,
sep = ";",
)
SINKS_folds <- dir_folds %>%
paste0(., "SINKS_folds.csv") %>%
read.table(
header = TRUE,
sep = ";",
)
profiles_folds <- dir_folds %>%
paste0(., "profiles_folds.csv") %>%
read.table(
header = TRUE,
sep = ";",
) %>%
right_join(values(profiles_texture)) %>%
select(lyr.1)
forest_folds <- dir_folds %>%
paste0(., "forest_folds.csv") %>%
read.table(
header = TRUE,
sep = ";",
)
# 4: Load covariate data
dir_cov <- dir_dat %>% paste0(., "/covariates")
cov_cats <- dir_code %>%
paste0(., "/cov_categories_20230501.csv") %>%
read.table(
sep = ";",
header = TRUE
)
cov_files <- dir_cov %>% list.files()
cov_names <- cov_files %>% tools::file_path_sans_ext()
cov_names %>%
write.table(
paste0("cov_names_", Sys.Date(), ".csv")
)
cov_names[!cov_names %in% cov_cats$name]
# 5: Load extracted covariates
dir_extr <- dir_dat %>%
paste0(., "/extracts/")
usebuffer <- FALSE
if (usebuffer) {
dsc_extr <- dir_extr %>%
paste0(., "/buffer_dsc_extr.csv") %>%
read.table(
header = TRUE,
sep = ";",
)
SEGES_extr <- dir_extr %>%
paste0(., "/buffer_SEGES_extr.csv") %>%
read.table(
header = TRUE,
sep = ";",
)
} else {
dsc_extr <- dir_extr %>%
paste0(., "/dsc_extr.rds") %>%
readRDS()
SEGES_extr <- dir_extr %>%
paste0(., "/SEGES_extr.rds") %>%
readRDS()
}
SINKS_extr <- dir_extr %>%
paste0(., "/SINKS_extr.rds") %>%
readRDS()
profiles_extr <- dir_extr %>%
paste0(., "profiles_extr.rds") %>%
readRDS() %>%
right_join(values(profiles_texture)) %>%
select(any_of(cov_names))
SINKS_extr <- dir_extr %>%
paste0(., "/SINKS_extr.rds") %>%
readRDS()
forests_extr <- dir_extr %>%
paste0(., "/forests_extr.rds") %>%
readRDS()
# 6: Merge data and transform the target variables
obs_data <- list(dsc, SEGES, SINKS, profiles_texture, forest_samples) %>%
vect() %>%
values() %>%
mutate(
logSOC = log(SOC),
logCaCO3 = log(CaCO3),
year = date %>%
as.character() %>%
substr(start = 1, stop = 4) %>%
as.numeric()
)
fractions <- c("clay", "silt", "fine_sand", "coarse_sand", "logSOC", "logCaCO3")
fractions_alt <- c("clay", "silt", "fine_sand", "coarse_sand", "SOC", "CaCO3")
fractions <- fractions_alt
fraction_names <- c(
"Clay", "Silt", "Fine sand", "Coarse sand", "SOC", "CaCO3"
)
# bounds_lower <- c(0, 0, 0, 0, NA, NA)
bounds_lower <- rep(0, 6)
# bounds_upper <- c(100, 100, 100, 100, log(100), log(100))
bounds_upper <- rep(100, 6)
# 7: Make training data
folds <- bind_rows(
dsc_folds,
SEGES_folds,
SINKS_folds,
profiles_folds,
forest_folds
)
names(folds) <- "fold"
extr <- bind_rows(
dsc_extr,
SEGES_extr,
SINKS_extr,
profiles_extr,
forests_extr
)
obs <- cbind(obs_data, extr, folds) %>%
filter(!is.na(UTMX) & !is.na(UTMY))
obs %<>%
rownames_to_column() %>%
mutate(ID_new = rowname, .before = everything()) %>%
select(-rowname)
obs_top <- obs %>%
filter(
upper < 25,
is.finite(fold)
)
obs_prf <- obs %>%
filter(
db == "Profile database",
is.finite(fold)
)
# Make new ID
# Use all observations?
obs_top_v <- obs_top %>% vect(geom = c("UTMX", "UTMY"))
?`plot,SpatVector,missing-method`
plot(obs_top_v, "clay", breaks = 5, breakby = "cases", col = cividis(5), cex = 1)
library(viridisLite)
plot(obs_top_v, "clay", breaks = 5, breakby = "cases", col = cividis(5), cex = 1)
plot(obs_top_v, "clay", breaks = 5, breakby = "cases", col = cividis(5), cex = 2)
plot(obs_top_v, "clay", breaks = 5, breakby = "cases", col = cividis(5), cex = 0.5)
plot(obs_top_v, "clay", breaks = 5, breakby = "cases", col = cividis(5), cex = 0.2)
plot(obs_top_v, "clay", breaks = 5, breakby = "cases", col = cividis(5), cex = 0.3)
plot(obs_top_v, "clay", breaks = 5, breakby = "cases", col = cividis(5), cex = 0.4)
tiff(
paste0(dir_results, "/obs_map_test", testn, ".tiff"),
width = 15,
height = 10,
units = "cm",
res = 300
)
plot(
obs_top_v, "clay", breaks = 5, breakby = "cases", col = cividis(5),
cex = 0.2
)
try(dev.off())
try(dev.off())
plot(
obs_top_v, "clay", breaks = 5, breakby = "cases", col = cividis(5),
cex = 0.4, plg = list(cex = 1)
)
plot(
obs_top_v, "clay", breaks = 5, breakby = "cases", col = cividis(5),
cex = 0.4, plg = list(cex = 2)
)
tiff(
paste0(dir_results, "/obs_map_test", testn, ".tiff"),
width = 15,
height = 10,
units = "cm",
res = 300
)
plot(
obs_top_v, "clay", breaks = 5, breakby = "cases", col = cividis(5),
cex = 0.2
)
try(dev.off())
try(dev.off())
plot(
obs_top_v, "clay", breaks = 5, breakby = "cases", col = cividis(5),
cex = 0.4
)
# 8: Set up models
cov_selected <- cov_cats %>%
filter(anbm_use == 1) %>%
dplyr::select(., name) %>%
unlist() %>%
unname()
# Template for custom eval
# evalerror <- function(preds, dtrain) {
#   labels <- getinfo(dtrain, "label")
#   err <- as.numeric(sum(labels != (preds > 0)))/length(labels)
#   return(list(metric = "error", value = err))
# }
# Weighted RMSE
get_RMSEw <- function(d, w)
{
sqe <- w*(d[, 1] - d[, 2])^2
msqe <- sum(sqe)/sum(w)
out <- sqrt(msqe)
return(out)
}
# Weighted R^2
get_R2w <- function(d, w)
{
require(boot)
out <- boot::corr(d[, 1:2], w)^2
return(out)
}
# Weighted summary function
WeightedSummary <- function (
data,
lev = NULL,
model = NULL,
...
) {
out <- numeric()
# Weighted RMSE
get_RMSEw <- function(d, w) {
sqe <- w*(d[, 1] - d[, 2])^2
msqe <- sum(sqe)/sum(w)
out <- sqrt(msqe)
return(out)
}
# Weighted R^2
get_R2w <- function(d, w)
{
require(boot)
out <- boot::corr(d[, 1:2], w)^2
return(out)
}
out[1] <- get_RMSEw(data[, 1:2], data$weights)
out[2] <- get_R2w(data[, 1:2], data$weights)
names(out) <- c('RMSEw', 'R2w')
return(out)
}
# Tuning grid
tgrid <- expand.grid(
nrounds = 100,
eta = seq(0.1, 1, 0.1),
max_depth = 6,
min_child_weight = 1,
gamma = 0,
colsample_bytree = 0.5,
subsample = 0.3
)
max_depth_test <- seq(1, 20, 3)
min_child_weight_test <- c(1, 2, 4, 8, 16, 32)
gamma_test <- seq(0, 0.5, 0.1)
objectives <- c(rep("reg:squarederror", 4), rep("reg:tweedie", 2))
trees_per_round <- 10
# Small random sample for testing
# Remember to include full dataset in the final model
n <- 1000
use_all_points <- TRUE
# use_all_points <- FALSE
# 9: Train models
extra_tuning_xgb <- TRUE
models <- list()
for (i in 1:length(fractions))
{
frac <- fractions[i]
print(frac)
cov_c_i <- cov_selected %>%
c("upper", "lower") %>%
paste0(collapse = " + ")
if (i %in% 1:4) {
cov_c_i <- cov_selected %>%
c("upper", "lower") %>%
c(., "SOM_removed") %>%
paste0(collapse = " + ")
} else {
if (i == 5) {
cov_c_i <- cov_selected %>%
c("upper", "lower") %>%
c(., "year") %>%
paste0(collapse = " + ")
}
}
formula_i <- paste0(frac, " ~ ", cov_c_i) %>%
as.formula()
# trdat <- obs_top %>%
#   filter(is.finite(.data[[frac]]))
trdat <- obs %>%
filter(is.finite(.data[[frac]])) %>%
filter(!is.na(UTMX) & !is.na(UTMX)) %>%
filter(lower > 0, upper < 200)
# Three folds (placeholder)
trdat %<>% mutate(
fold = ceiling(fold/3)
)
holdout_i <- trdat %>%
filter(fold == 4)
trdat %<>% filter(fold < 4)
if (!use_all_points) {
trdat %<>% sample_n(n)
}
# Calculate weights
# Calculate densities for depth intervals
# dens <- ppp(
#   trdat$UTMX,
#   trdat$UTMY,
#   c(441000, 894000),
#   c(6049000, 6403000)
# ) %>%
#   density(
#     sigma = 250,
#     at = 'points',
#     leaveoneout = FALSE
#   )
#
# attributes(dens) <- NULL
#
# min(dens)
# max(dens)
#
# trdat %<>%
#   mutate(
#     density = dens,
#     w = min(dens) / dens
#   )
# Weighting by depth intervals
w_interval <- 10
w_increment <- 1
w_startdepth <- 0
w_maxdepth <- 200
w_iterations <- round(w_maxdepth / w_increment, digits = 0)
dens_mat <- matrix(numeric(), nrow = nrow(trdat), ncol = w_iterations)
for(j in 1:w_iterations)
{
upper_j <- w_startdepth + w_increment*(j - 1)
lower_j <- upper_j + w_interval
trdat_ind <- trdat$lower > upper_j & trdat$upper < lower_j
trdat_ind[is.na(trdat_ind)] <- FALSE
trdat_j <- trdat[trdat_ind, ]
#sigma equal to the radius of a cirkle with an equal area per sample
sigma_j <- sqrt(42951/(nrow(trdat_j)*pi))*1000
# separate densities for wetlands and uplands
dens_j <- numeric(nrow(trdat_j))
for(k in 0:1) {
trdat_j_wl_ind <- trdat_j$wetlands_10m == k
trdat_jk <- trdat_j[trdat_j_wl_ind]
dens_jk <- ppp(
trdat_jk$UTMX,
trdat_jk$UTMY,
c(441000, 894000),
c(6049000, 6403000)
) %>%
density(
sigma = sigma_j,
at = 'points',
leaveoneout = FALSE
)
attributes(dens_jk) <- NULL
dens_j[trdat_j_wl_ind] <- dens_jk
}
# dens_j <- ppp(
#   trdat_j$UTMX,
#   trdat_j$UTMY,
#   c(441000, 894000),
#   c(6049000, 6403000)
# ) %>%
#   density(
#     sigma = sigma_j,
#     at = 'points',
#     leaveoneout = FALSE
#   )
#
# attributes(dens_j) <- NULL
dens_mat[trdat_ind, j] <- dens_j
}
dens_depth <- apply(
dens_mat,
1,
function(x) {
out <- mean(x, na.rm = TRUE)
return(out)
}
)
w_depth <- min(dens_depth, na.rm = TRUE) / dens_depth
w_depth[!is.finite(w_depth)] <- 1
trdat$w <- w_depth
# List of folds
folds_i <- lapply(
unique(trdat$fold),
function(x) {
out <- trdat %>%
mutate(
is_j = fold != x,
rnum = row_number(),
ind_j = is_j*rnum
) %>%
filter(ind_j != 0) %>%
dplyr::select(., ind_j) %>%
unlist() %>%
unname()
}
)
showConnections()
# cl <- makePSOCKcluster(10)
# registerDoParallel(cl)
# xgboost optimization
# 1: Fit learning rate (eta) and nrounds
print("Step 1")
set.seed(1)
models[[i]] <- caret::train(
form = formula_i,
data = trdat,
method = "xgbTree",
na.action = na.pass,
tuneGrid = tgrid,
trControl = trainControl(
index = folds_i,
savePredictions = "final",
predictionBounds = c(bounds_lower[i], bounds_upper[i]),
summaryFunction = WeightedSummary,
allowParallel = FALSE
),
metric = 'RMSEw',
maximize = FALSE,
weights = trdat$w,
num_parallel_tree = trees_per_round,
objective = objectives[i]
)
# registerDoSEQ()
# rm(cl)
if (extra_tuning_xgb) {
# 2: Fit max_depth and min_child_weight
print("Step 2")
set.seed(1)
model2 <- caret::train(
form = formula_i,
data = trdat,
method = "xgbTree",
na.action = na.pass,
tuneGrid = expand.grid(
nrounds = models[[i]]$bestTune$nrounds,
eta = models[[i]]$bestTune$eta,
max_depth = max_depth_test,  # NB
min_child_weight = min_child_weight_test,  # NB
gamma = models[[i]]$bestTune$gamma,
colsample_bytree = models[[i]]$bestTune$colsample_bytree,
subsample = models[[i]]$bestTune$subsample
),
trControl = trainControl(
index = folds_i,
savePredictions = "final",
predictionBounds = c(bounds_lower[i], bounds_upper[i]),
summaryFunction = WeightedSummary,
allowParallel = FALSE
),
metric = 'RMSEw',
maximize = FALSE,
weights = trdat$w,
num_parallel_tree = trees_per_round,
objective = objectives[i]
)
# 3: Tune gamma
print("Step 3")
set.seed(1)
model3 <- caret::train(
form = formula_i,
data = trdat,
method = "xgbTree",
na.action = na.pass,
tuneGrid = expand.grid(
nrounds = models[[i]]$bestTune$nrounds,
eta = models[[i]]$bestTune$eta,
max_depth = model2$bestTune$max_depth,
min_child_weight = model2$bestTune$min_child_weight,
gamma = gamma_test,  # NB
colsample_bytree = models[[i]]$bestTune$colsample_bytree,
subsample = models[[i]]$bestTune$subsample
),
trControl = trainControl(
index = folds_i,
savePredictions = "final",
predictionBounds = c(bounds_lower[i], bounds_upper[i]),
summaryFunction = WeightedSummary,
allowParallel = FALSE
),
metric = 'RMSEw',
maximize = FALSE,
weights = trdat$w,
num_parallel_tree = trees_per_round,
objective = objectives[i]
)
models[[i]] <- model3
}
print(models[[i]])
saveRDS(
models[[i]],
paste0(dir_results, "/model_", frac, ".rds")
)
}
