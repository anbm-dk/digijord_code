#       c(., "year")
#   }
# }
# # CS Step 1: Decide the optimal number of OGCs
# ogcs_names <- grep('ogc_pi', cov_c_i, value = TRUE)
# covs_not_ogc <- grep('ogc_pi', cov_c_i, value = TRUE, invert = TRUE)
#
# ogcs_names_list <- list(ogcs_names)
# n_ogcs_v <- numeric()
#
# m <- 1
# n_ogcs <- length(ogcs_names_list[[m]])
# n_ogcs_v[m] <- n_ogcs
#
# while (n_ogcs > 2) {
#   m <- m + 1
#   ogcs_names_list[[m]] <- ogcs_names_list[[m - 1]][c(TRUE, FALSE)]
#   n_ogcs <- length(ogcs_names_list[[m]])
#   n_ogcs_v[m] <- n_ogcs
# }
#
# ogcs_names_list %<>% lapply(., function(x) {c(covs_not_ogc, x)})
# ogcs_names_list[[length(ogcs_names_list) + 1]] <- covs_not_ogc
# n_ogcs_v %<>% c(., 0)
#
# print("Testing OGCs")
#
# models_ogc_test <- ogcs_names_list %>%
#   lapply(
#     .,
#     function(x) {
#       cov_p_i <- x %>% paste0(collapse = " + ")
#
#       formula_i <- paste0(frac, " ~ ", cov_p_i) %>%
#         as.formula()
#
#       set.seed(1)
#
#       out <- caret::train(
#         form = formula_i,
#         data = trdat,
#         method = "xgbTree",
#         na.action = na.pass,
#         tuneGrid = tgrid,
#         trControl = trainControl(
#           index = folds_i,
#           savePredictions = "final",
#           predictionBounds = c(bounds_lower[i], bounds_upper[i]),
#           summaryFunction = sumfun,
#           allowParallel = FALSE
#         ),
#         metric = metrics[i],
#         maximize = FALSE,
#         weights = trdat$w,
#         num_parallel_tree = trees_per_round,
#         objective = objectives[i]
#       )
#       return(out)
#     }
#   )
#
# ogc_results <- models_ogc_test %>% lapply(
#   ., function(x) x$results %>% select(any_of(metrics[i])) %>% min()
# ) %>%
#   unlist()
#
# which_ogc_ind <- which.min(ogc_results)
#
# ogc_df <- data.frame(
#   fraction = frac,
#   n_ogcs = n_ogcs_v,
#   acc = ogc_results,
#   metric = metrics[i]
# )
#
# write.table(
#   ogc_df,
#   paste0(dir_results, "ogc_acc_", frac, ".csv"),
#   row.names = FALSE,
#   col.names = TRUE,
#   sep = ";"
#   )
#
# n_ogcs_models[i] <- n_ogcs_v[which_ogc_ind]
#
# # CS Step 2: Drop unimportant covariates
# cov_c_i <- varImp(models_ogc_test[[which_ogc_ind]])$importance %>%
#   rownames_to_column() %>%
#   mutate(scaled = Overall/sum(Overall),
#          cumul = cumsum(scaled)) %>%
#   filter(cumul < 0.99) %>%
#   .$rowname
#
# cov_p_i <- cov_c_i %>% paste0(collapse = " + ")
#
# formula_i <- paste0(frac, " ~ ", cov_p_i) %>%
#   as.formula()
# Identify OGCs and other covariates
ogcs_names <- grep('ogc_pi', cov_c_i, value = TRUE)
covs_not_ogc <- grep('ogc_pi', cov_c_i, value = TRUE, invert = TRUE)
cov_p_i <- covs_not_ogc %>% paste0(collapse = " + ")
formula_i <- paste0(frac, " ~ ", cov_p_i) %>%
as.formula()
# xgboost optimization
# 1: Fit learning rate (eta)
print("Step 1: Fit learning rate (eta)")
set.seed(1)
models[[i]] <- caret::train(
form = formula_i,
data = trdat,
method = "xgbTree",
na.action = na.pass,
tuneGrid = expand.grid(
nrounds = tgrid$nrounds,
eta = eta_test, # NB
max_depth = tgrid$max_depth,
min_child_weight = tgrid$min_child_weight,
gamma = tgrid$gamma,
colsample_bytree = tgrid$colsample_bytree,
subsample = tgrid$subsample
),
trControl = trainControl(
index = folds_i,
savePredictions = "final",
predictionBounds = c(bounds_lower[i], bounds_upper[i]),
summaryFunction = sumfun,
allowParallel = FALSE
),
metric = metrics[i],
maximize = FALSE,
weights = trdat$w,
num_parallel_tree = trees_per_round,
objective = objectives[i],
colsample_bylevel = 0.1
)
models_tr_summaries[[i]][[tr_step]] <- models[[i]]$results
print(models_tr_summaries[[i]][[tr_step]])
tr_step %<>% `+`(1)
# CS Step 1: Drop unimportant covariates
cov_c_i <- varImp(models[[i]])$importance %>%
rownames_to_column() %>%
mutate(scaled = Overall/sum(Overall),
cumul = cumsum(scaled)) %>%
filter(cumul < 0.99) %>%
.$rowname
cov_p_i <- cov_c_i %>% paste0(collapse = " + ")
formula_i <- paste0(frac, " ~ ", cov_p_i) %>%
as.formula()
if (extra_tuning_xgb) {
# xgb opt Step 2: Fit max_depth and min_child_weight
print("Step 2: Fit max_depth and min_child_weight")
set.seed(1)
model2 <- caret::train(
form = formula_i,
data = trdat,
method = "xgbTree",
na.action = na.pass,
tuneGrid = expand.grid(
nrounds = models[[i]]$bestTune$nrounds,
eta = models[[i]]$bestTune$eta,
max_depth = max_depth_test, # NB
min_child_weight = min_child_weight_test, # NB
gamma = models[[i]]$bestTune$gamma,
colsample_bytree = models[[i]]$bestTune$colsample_bytree,
subsample = models[[i]]$bestTune$subsample
),
trControl = trainControl(
index = folds_i,
savePredictions = "final",
predictionBounds = c(bounds_lower[i], bounds_upper[i]),
summaryFunction = sumfun,
allowParallel = FALSE
),
metric = metrics[i],
maximize = FALSE,
weights = trdat$w,
num_parallel_tree = trees_per_round,
objective = objectives[i]
)
models[[i]] <- model2
models_tr_summaries[[i]][[tr_step]] <- models[[i]]$results
print(models_tr_summaries[[i]][[tr_step]])
tr_step %<>% `+`(1)
# xgb opt Step 3: Tune gamma
print("Step 3: Tune gamma")
set.seed(1)
model3 <- caret::train(
form = formula_i,
data = trdat,
method = "xgbTree",
na.action = na.pass,
tuneGrid = expand.grid(
nrounds = models[[i]]$bestTune$nrounds,
eta = models[[i]]$bestTune$eta,
max_depth = models[[i]]$bestTune$max_depth,
min_child_weight = models[[i]]$bestTune$min_child_weight,
gamma = gamma_test, # NB
colsample_bytree = models[[i]]$bestTune$colsample_bytree,
subsample = models[[i]]$bestTune$subsample
),
trControl = trainControl(
index = folds_i,
savePredictions = "final",
predictionBounds = c(bounds_lower[i], bounds_upper[i]),
summaryFunction = sumfun,
allowParallel = FALSE
),
metric = metrics[i],
maximize = FALSE,
weights = trdat$w,
num_parallel_tree = trees_per_round,
objective = objectives[i]
)
models[[i]] <- model3
models_tr_summaries[[i]][[tr_step]] <- models[[i]]$results
print(models_tr_summaries[[i]][[tr_step]])
tr_step %<>% `+`(1)
# xgb opt Step 4: Adjust subsampling
print("Step 4: Adjust subsampling")
set.seed(1)
model4 <- caret::train(
form = formula_i,
data = trdat,
method = "xgbTree",
na.action = na.pass,
tuneGrid = expand.grid(
nrounds = models[[i]]$bestTune$nrounds,
eta = models[[i]]$bestTune$eta,
max_depth = models[[i]]$bestTune$max_depth,
min_child_weight = models[[i]]$bestTune$min_child_weight,
gamma = models[[i]]$bestTune$gamma,
colsample_bytree = colsample_bytree_test,
subsample = subsample_test
),
trControl = trainControl(
index = folds_i,
savePredictions = "final",
predictionBounds = c(bounds_lower[i], bounds_upper[i]),
summaryFunction = sumfun,
allowParallel = FALSE
),
metric = metrics[i],
maximize = FALSE,
weights = trdat$w,
num_parallel_tree = trees_per_round,
objective = objectives[i]
)
models[[i]] <- model4
models_tr_summaries[[i]][[tr_step]] <- models[[i]]$results
print(models_tr_summaries[[i]][[tr_step]])
tr_step %<>% `+`(1)
# CS Step 2: Decide the optimal number of OGCs
cov_c_i <- varImp(models[[i]])$importance %>%
rownames_to_column() %>%
.$rowname
ogcs_names_list <- list(ogcs_names)
n_ogcs_v <- numeric()
m <- 1
n_ogcs <- length(ogcs_names_list[[m]])
n_ogcs_v[m] <- n_ogcs
while (n_ogcs > 2) {
m <- m + 1
ogcs_names_list[[m]] <- ogcs_names_list[[m - 1]][c(TRUE, FALSE)]
n_ogcs <- length(ogcs_names_list[[m]])
n_ogcs_v[m] <- n_ogcs
}
ogcs_names_list %<>% lapply(., function(x) {c(cov_c_i, x)})
ogcs_names_list[[length(ogcs_names_list) + 1]] <- cov_c_i
n_ogcs_v %<>% c(., 0)
print("Testing OGCs")
models_ogc_test <- ogcs_names_list %>%
lapply(
.,
function(x) {
cov_p_i <- x %>% paste0(collapse = " + ")
formula_i <- paste0(frac, " ~ ", cov_p_i) %>%
as.formula()
set.seed(1)
out <- caret::train(
form = formula_i,
data = trdat,
method = "xgbTree",
na.action = na.pass,
tuneGrid = expand.grid(
nrounds = models[[i]]$bestTune$nrounds,
eta = models[[i]]$bestTune$eta,
max_depth = models[[i]]$bestTune$max_depth,
min_child_weight = models[[i]]$bestTune$min_child_weight,
gamma = models[[i]]$bestTune$gamma,
colsample_bytree = models[[i]]$bestTune$colsample_bytree,
subsample = models[[i]]$bestTune$subsample
),
trControl = trainControl(
index = folds_i,
savePredictions = "final",
predictionBounds = c(bounds_lower[i], bounds_upper[i]),
summaryFunction = sumfun,
allowParallel = FALSE
),
metric = metrics[i],
maximize = FALSE,
weights = trdat$w,
num_parallel_tree = trees_per_round,
objective = objectives[i]
)
return(out)
}
)
ogc_results <- models_ogc_test %>% lapply(
., function(x) x$results %>% select(any_of(metrics[i])) %>% min()
) %>%
unlist()
which_ogc_ind <- which.min(ogc_results)
ogc_df <- data.frame(
fraction = frac,
n_ogcs = n_ogcs_v,
acc = ogc_results,
metric = metrics[i]
)
write.table(
ogc_df,
paste0(dir_results, "ogc_acc_", frac, ".csv"),
row.names = FALSE,
col.names = TRUE,
sep = ";"
)
models_tr_summaries[[i]][[tr_step]] <- ogc_df
print(models_tr_summaries[[i]][[tr_step]])
tr_step %<>% `+`(1)
n_ogcs_models[i] <- n_ogcs_v[which_ogc_ind]
models[[i]] <- models_ogc_test[[which_ogc_ind]]
cov_c_i <- varImp(models_ogc_test[[which_ogc_ind]])$importance %>%
rownames_to_column() %>%
.$rowname
cov_p_i <- cov_c_i %>% paste0(collapse = " + ")
formula_i <- paste0(frac, " ~ ", cov_p_i) %>%
as.formula()
# xgb opt Step 5: Increase nrounds, readjust learning rate
print("Step 5")
eta_test_final <- model4$bestTune$eta %>%
log() %>%
seq(., . + log(0.01), length.out = 9) %>%
exp() %>%
round(3)
set.seed(1)
model5 <- caret::train(
form = formula_i,
data = trdat,
method = "xgbTree",
na.action = na.pass,
tuneGrid = expand.grid(
nrounds = models[[i]]$bestTune$nrounds*10,
eta = eta_test_final, # NB
max_depth = models[[i]]$bestTune$max_depth,
min_child_weight = models[[i]]$bestTune$min_child_weight,
gamma = models[[i]]$bestTune$gamma,
colsample_bytree = models[[i]]$bestTune$colsample_bytree,
subsample = models[[i]]$bestTune$subsample
),
trControl = trainControl(
index = folds_i,
savePredictions = "final",
predictionBounds = c(bounds_lower[i], bounds_upper[i]),
summaryFunction = sumfun,
allowParallel = FALSE
),
metric = metrics[i],
maximize = FALSE,
weights = trdat$w,
num_parallel_tree = trees_per_round,
objective = objectives[i]
)
models[[i]] <- model5
models_tr_summaries[[i]][[tr_step]] <- models[[i]]$results
print(models_tr_summaries[[i]][[tr_step]])
tr_step %<>% `+`(1)
}
print(models[[i]])
models_predictions[trdat_indices, i] <- models[[i]]$pred %>%
arrange(rowIndex) %>%
distinct(rowIndex, .keep_all = TRUE) %>%
dplyr::select(., pred) %>%
unlist() %>%
unname()
models_predictions[holdout_indices, i] <- predict_passna(
models[[i]],
holdout_i,
n_const = 3
)
saveRDS(
models[[i]],
paste0(dir_results, "/model_", frac, ".rds")
)
}
varImp(models[[1]])
ogcs_names <- grep('ogc_pi', cov_c_i, value = TRUE)
covs_not_ogc <- grep('ogc_pi', cov_c_i, value = TRUE, invert = TRUE)
cov_p_i <- covs_not_ogc %>% paste0(collapse = " + ")
ogcs_names_list <- list(ogcs_names)
n_ogcs_v <- numeric()
m <- 1
n_ogcs <- length(ogcs_names_list[[m]])
n_ogcs_v[m] <- n_ogcs
while (n_ogcs > 2) {
m <- m + 1
ogcs_names_list[[m]] <- ogcs_names_list[[m - 1]][c(TRUE, FALSE)]
n_ogcs <- length(ogcs_names_list[[m]])
n_ogcs_v[m] <- n_ogcs
}
ogcs_names_list %<>% lapply(., function(x) {c(cov_c_i, x)})
ogcs_names_list[[length(ogcs_names_list) + 1]] <- cov_c_i
n_ogcs_v %<>% c(., 0)
ogcs_names_list
length(ogcs_names_list)
n_ogcs_v
ogcs_names
n_ogcs
ogcs_names_list
# Add depth boundaries and methods as covariates
cov_c_i <- cov_selected %>%
c("upper", "lower")
if (i %in% 1:4) {
cov_c_i <- cov_selected %>%
c("upper", "lower") %>%
c(., "SOM_removed")
}
ogcs_names <- grep('ogc_pi', cov_c_i, value = TRUE)
covs_not_ogc <- grep('ogc_pi', cov_c_i, value = TRUE, invert = TRUE)
ogcs_names
ogcs_names_list <- list(ogcs_names)
n_ogcs_v <- numeric()
m <- 1
n_ogcs <- length(ogcs_names_list[[m]])
n_ogcs
while (n_ogcs > 2) {
m <- m + 1
ogcs_names_list[[m]] <- ogcs_names_list[[m - 1]][c(TRUE, FALSE)]
n_ogcs <- length(ogcs_names_list[[m]])
n_ogcs_v[m] <- n_ogcs
}
n_ogcs
n_ogcs_v
ogcs_names_list <- list(ogcs_names)
n_ogcs_v <- numeric()
m <- 1
n_ogcs <- length(ogcs_names_list[[m]])
n_ogcs_v[m] <- n_ogcs
n_ogcs
n_ogcs_v
ogcs_names_list
while (n_ogcs > 2) {
m <- m + 1
ogcs_names_list[[m]] <- ogcs_names_list[[m - 1]][c(TRUE, FALSE)]
n_ogcs <- length(ogcs_names_list[[m]])
n_ogcs_v[m] <- n_ogcs
}
ogcs_names_list
cov_c_i
ogcs_names_list %<>% lapply(., function(x) {c(cov_c_i, x)})
ogcs_names_list[[length(ogcs_names_list) + 1]] <- cov_c_i
n_ogcs_v %<>% c(., 0)
n_ogcs_v
ogcs_names_list
extr
names(extr)
extr %>%
names() %>%
grep('ogc_pi', . value = TRUE)
extr %>%
names() %>%
grep('ogc_pi', ., value = TRUE)
ogcs_names <- extr %>%
names() %>%
grep('ogc_pi', ., value = TRUE)
ogcs_names <- extr %>%
names() %>%
grep('ogc_pi', ., value = TRUE)
ogcs_names_list <- list(ogcs_names)
n_ogcs_v <- numeric()
m <- 1
n_ogcs <- length(ogcs_names_list[[m]])
n_ogcs_v[m] <- n_ogcs
while (n_ogcs > 2) {
m <- m + 1
ogcs_names_list[[m]] <- ogcs_names_list[[m - 1]][c(TRUE, FALSE)]
n_ogcs <- length(ogcs_names_list[[m]])
n_ogcs_v[m] <- n_ogcs
}
ogcs_names_list[[length(ogcs_names_list) + 1]] <- character()
n_ogcs_v %<>% c(., 0)
ogcs_names_list
c("a", ogcs_names_list[[1]])
c("a", ogcs_names_list[[7]])
ogcs_names <- extr %>%
names() %>%
grep('ogc_pi', ., value = TRUE)
ogcs_names_list <- list(ogcs_names)
n_ogcs_v <- numeric()
m <- 1
n_ogcs <- length(ogcs_names_list[[m]])
n_ogcs_v[m] <- n_ogcs
while (n_ogcs > 2) {
m <- m + 1
ogcs_names_list[[m]] <- ogcs_names_list[[m - 1]][c(TRUE, FALSE)]
n_ogcs <- length(ogcs_names_list[[m]])
n_ogcs_v[m] <- n_ogcs
}
ogcs_names_list[[length(ogcs_names_list) + 1]] <- character()
n_ogcs_v %<>% c(., 0)
models
1 %in% 1:4
5 %in% 1:4
