n_ogcs_v %<>% c(., 0)
print("Testing OGCs")
models_ogc_test <- ogcs_names_list %>%
lapply(
.,
function(x) {
cov_p_i <- x %>% paste0(collapse = " + ")
formula_i <- paste0(frac, " ~ ", cov_p_i) %>%
as.formula()
set.seed(1)
out <- caret::train(
form = formula_i,
data = trdat,
method = "xgbTree",
na.action = na.pass,
tuneGrid = tgrid,
trControl = trainControl(
index = folds_i,
savePredictions = "final",
predictionBounds = c(bounds_lower[i], bounds_upper[i]),
summaryFunction = sumfun,
allowParallel = FALSE
),
metric = metrics[i],
maximize = FALSE,
weights = trdat$w,
num_parallel_tree = trees_per_round,
objective = objectives[i]
)
return(out)
}
)
ogc_results <- models_ogc_test %>% lapply(
., function(x) x$results %>% select(any_of(metrics[i])) %>% min()
) %>%
unlist()
which_ogc_ind <- which.min(ogc_results)
ogc_df <- data.frame(
fraction = frac,
n_ogcs = n_ogcs_v,
acc = ogc_results,
metric = metrics[i]
)
write.table(
ogc_df,
paste0(dir_results, "ogc_acc_", frac, ".csv"),
row.names = FALSE,
col.names = TRUE,
sep = ";"
)
n_ogcs_models[i] <- n_ogcs_v[which_ogc_ind]
# CS Step 2: Drop unimportant covariates
cov_c_i <- varImp(models_ogc_test[[which_ogc_ind]])$importance %>%
rownames_to_column() %>%
mutate(scaled = Overall/sum(Overall),
cumul = cumsum(scaled)) %>%
filter(cumul < 0.99) %>%
.$rowname
cov_p_i <- cov_c_i %>% paste0(collapse = " + ")
formula_i <- paste0(frac, " ~ ", cov_p_i) %>%
as.formula()
# xgboost optimization
# 1: Fit learning rate (eta) [and nrounds]
print("Step 1")
set.seed(1)
models[[i]] <- caret::train(
form = formula_i,
data = trdat,
method = "xgbTree",
na.action = na.pass,
tuneGrid = expand.grid(
nrounds = tgrid$nrounds,
eta = eta_test, # NB
max_depth = tgrid$max_depth,
min_child_weight = tgrid$min_child_weight,
gamma = tgrid$gamma,
colsample_bytree = tgrid$colsample_bytree,
subsample = tgrid$subsample
),
trControl = trainControl(
index = folds_i,
savePredictions = "final",
predictionBounds = c(bounds_lower[i], bounds_upper[i]),
summaryFunction = sumfun,
allowParallel = FALSE
),
metric = metrics[i],
maximize = FALSE,
weights = trdat$w,
num_parallel_tree = trees_per_round,
objective = objectives[i]
)
# registerDoSEQ()
# rm(cl)
if (extra_tuning_xgb) {
# xgb opt Step 2: Fit max_depth and min_child_weight
print("Step 2")
set.seed(1)
model2 <- caret::train(
form = formula_i,
data = trdat,
method = "xgbTree",
na.action = na.pass,
tuneGrid = expand.grid(
nrounds = models[[i]]$bestTune$nrounds,
eta = models[[i]]$bestTune$eta,
max_depth = max_depth_test, # NB
min_child_weight = min_child_weight_test, # NB
gamma = models[[i]]$bestTune$gamma,
colsample_bytree = models[[i]]$bestTune$colsample_bytree,
subsample = models[[i]]$bestTune$subsample
),
trControl = trainControl(
index = folds_i,
savePredictions = "final",
predictionBounds = c(bounds_lower[i], bounds_upper[i]),
summaryFunction = sumfun,
allowParallel = FALSE
),
metric = metrics[i],
maximize = FALSE,
weights = trdat$w,
num_parallel_tree = trees_per_round,
objective = objectives[i]
)
# xgb opt Step 3: Tune gamma
print("Step 3")
set.seed(1)
model3 <- caret::train(
form = formula_i,
data = trdat,
method = "xgbTree",
na.action = na.pass,
tuneGrid = expand.grid(
nrounds = model2$bestTune$nrounds,
eta = model2$bestTune$eta,
max_depth = model2$bestTune$max_depth,
min_child_weight = model2$bestTune$min_child_weight,
gamma = gamma_test, # NB
colsample_bytree = model2$bestTune$colsample_bytree,
subsample = model2$bestTune$subsample
),
trControl = trainControl(
index = folds_i,
savePredictions = "final",
predictionBounds = c(bounds_lower[i], bounds_upper[i]),
summaryFunction = sumfun,
allowParallel = FALSE
),
metric = metrics[i],
maximize = FALSE,
weights = trdat$w,
num_parallel_tree = trees_per_round,
objective = objectives[i]
)
models[[i]] <- model3
# xgb opt Step 4: Adjust subsampling
print("Step 4")
set.seed(1)
model4 <- caret::train(
form = formula_i,
data = trdat,
method = "xgbTree",
na.action = na.pass,
tuneGrid = expand.grid(
nrounds = model3$bestTune$nrounds,
eta = model3$bestTune$eta,
max_depth = model3$bestTune$max_depth,
min_child_weight = model3$bestTune$min_child_weight,
gamma = model3$bestTune$gamma,
colsample_bytree = colsample_bytree_test,
subsample = subsample_test
),
trControl = trainControl(
index = folds_i,
savePredictions = "final",
predictionBounds = c(bounds_lower[i], bounds_upper[i]),
summaryFunction = sumfun,
allowParallel = FALSE
),
metric = metrics[i],
maximize = FALSE,
weights = trdat$w,
num_parallel_tree = trees_per_round,
objective = objectives[i]
)
# xgb opt Step 5: Increase nrounds, readjust learning rate
print("Step 5")
set.seed(1)
model5 <- caret::train(
form = formula_i,
data = trdat,
method = "xgbTree",
na.action = na.pass,
tuneGrid = expand.grid(
nrounds = model4$bestTune$nrounds*10,
eta = eta_test, # NB
max_depth = model4$bestTune$max_depth,
min_child_weight = model4$bestTune$min_child_weight,
gamma = model4$bestTune$gamma,
colsample_bytree = model4$bestTune$colsample_bytree,
subsample = model4$bestTune$subsample
),
trControl = trainControl(
index = folds_i,
savePredictions = "final",
predictionBounds = c(bounds_lower[i], bounds_upper[i]),
summaryFunction = sumfun,
allowParallel = FALSE
),
metric = metrics[i],
maximize = FALSE,
weights = trdat$w,
num_parallel_tree = trees_per_round,
objective = objectives[i]
)
models[[i]] <- model5
}
print(models[[i]])
saveRDS(
models[[i]],
paste0(dir_results, "/model_", frac, ".rds")
)
}
names(weights_objects) <- fractions
saveRDS(
weights_objects,
paste0(dir_results, "/weights_objects.rds")
)
# (last step: Reduce learning rate, use cv to optimize nrounds, early stopping)
models_loaded <- lapply(
1:6,
function(x) {
out <- fractions[x] %>%
paste0(dir_results, "/model_", ., ".rds") %>%
readRDS()
return(out)
}
)
models <- models_loaded
names(models) <- fractions
# Model summary
models_sum <- lapply(models, function(x) {
results <- x$results
if ("RMSEw" %in% names(results)) {
out <- results %>% filter(RMSEw == min(RMSEw))
} else {
if ("RMSEw_sqrt" %in% names(results)) {
out <- results %>% filter(RMSEw_sqrt == min(RMSEw_sqrt))
} else {
out <- results %>%
filter(RMSEw_log == min(RMSEw_log))
}
}
return(out)
}) %>%
bind_rows() %>%
mutate(
Fraction = fractions,
.before = 1
) %>% mutate(
ogcs = n_ogcs_models,
.after = 1
) %T>%
write.table(
file = paste0(dir_results, "/models_sum.csv"),
sep = ";",
row.names = FALSE
)
models_sum
# Covariate importance
imp_all <- models %>%
seq_along() %>%
lapply(
function(x) {
out <- varImp(models[[x]])$importance %>%
as.data.frame() %>%
rownames_to_column(var = "covariate") %>%
mutate(fraction = names(models)[x])
return(out)
}
) %>%
bind_rows() %>%
pivot_wider(
id_cols = covariate,
names_from = fraction,
values_from = Overall
) %>%
replace(is.na(.), 0) %>%
rowwise() %>%
mutate(mean_imp = mean(c_across(-covariate))) %>%
arrange(-mean_imp) %T>%
write.table(
file = paste0(dir_results, "/var_imp.csv"),
sep = ";",
row.names = FALSE
)
imp_all
# Inspect models
get_acc <- function(x2, i2) {
df <- x2$pred %>%
arrange(rowIndex) %>%
distinct(rowIndex, .keep_all = TRUE) %>%
dplyr::select(., c(pred, obs, weights)) %>%
mutate(
pred = ifelse(pred < 0, 0, pred)
)
# if (i2 > 4) df %<>% exp
df %<>% bind_cols(x2$trainingData)
r2_all <- df %$% get_R2w(cbind(pred, obs), weights)
r2_bare <- df %>%
filter(!is.na(s2_geomedian_b2)) %$%
get_R2w(cbind(pred, obs), weights)
r2_covered <- df %>%
filter(is.na(s2_geomedian_b2)) %$%
get_R2w(cbind(pred, obs), weights)
rmse_all <- df %$% get_RMSEw(cbind(pred, obs), weights)
rmse_bare <- df %>%
filter(!is.na(s2_geomedian_b2)) %$%
get_RMSEw(cbind(pred, obs), weights)
rmse_covered <- df %>%
filter(is.na(s2_geomedian_b2)) %$%
get_RMSEw(cbind(pred, obs), weights)
out <- data.frame(
r2_all,
r2_bare,
r2_covered,
rmse_all,
rmse_bare,
rmse_covered
)
return(out)
}
acc_all <- foreach(i = 1:6, .combine = rbind) %do%
get_acc(models[[i]], i)
i <- 1
depth_weights <- weights_objects[[i]]$w_cm_mat / weights_objects[[i]]$w_cm_sums
mdata <- models[[i]]$pred %>%
bind_cols(models[[i]]$trainingData)
d_out[[i]] <- apply(
depth_weights, 2,
function(x) {
ddat <- data.frame(
pred = mdata$pred,
obs = mdata$obs,
w_div = x,
weights = mdata$weights
) %>%
drop_na()
out <- data.frame(
# Fraction = fractions[i],
# Depth = seq(w_startdepth, w_maxdepth, w_increment),
RMSEw = get_RMSEw(
select(ddat, pred, obs),
ddat$w_div
),
R2w = get_R2w(
select(ddat, pred, obs),
ddat$w_div
),
Weights = sum(ddat$weights)
)
return(out)
}
) %>% bind_rows()
d_out <- list()
# This operation is somewhat slow
# Also calculate statistics by depth for the observations
i <- 1
depth_weights <- weights_objects[[i]]$w_cm_mat / weights_objects[[i]]$w_cm_sums
mdata <- models[[i]]$pred %>%
bind_cols(models[[i]]$trainingData)
d_out[[i]] <- apply(
depth_weights, 2,
function(x) {
ddat <- data.frame(
pred = mdata$pred,
obs = mdata$obs,
w_div = x,
weights = mdata$weights
) %>%
drop_na()
out <- data.frame(
# Fraction = fractions[i],
# Depth = seq(w_startdepth, w_maxdepth, w_increment),
RMSEw = get_RMSEw(
select(ddat, pred, obs),
ddat$w_div
),
R2w = get_R2w(
select(ddat, pred, obs),
ddat$w_div
),
Weights = sum(ddat$weights)
)
return(out)
}
) %>% bind_rows()
d_out
i <- 1
depth_weights <- weights_objects[[i]]$w_cm_mat / weights_objects[[i]]$w_cm_sums
mdata <- models[[i]]$pred %>%
bind_cols(models[[i]]$trainingData)
d_out[[i]] <- apply(
depth_weights, 2,
function(x) {
ddat <- data.frame(
pred = mdata$pred,
obs = mdata$obs,
w_div = x,
weights = mdata$weights
) %>%
drop_na()
out <- data.frame(
# Fraction = fractions[i],
# Depth = seq(w_startdepth, w_maxdepth, w_increment),
RMSEw = get_RMSEw(
select(ddat, pred, obs),
ddat$w_div
),
R2w = get_R2w(
select(ddat, pred, obs),
ddat$w_div
),
Weights = sum(w_div$weights)
)
return(out)
}
) %>% bind_rows()
depths_acc <- c(0:200)
d_interval_exp <- 10
d_out <- list()
# This operation is somewhat slow
# Also calculate statistics by depth for the observations
for (i in 1:length(models)) {
depth_weights <- weights_objects[[i]]$w_cm_mat / weights_objects[[i]]$w_cm_sums
mdata <- models[[i]]$pred %>%
bind_cols(models[[i]]$trainingData)
d_out[[i]] <- apply(
depth_weights, 2,
function(x) {
ddat <- data.frame(
pred = mdata$pred,
obs = mdata$obs,
w_div = x,
weights = mdata$weights
) %>%
drop_na()
out <- data.frame(
RMSEw = get_RMSEw(
select(ddat, pred, obs),
ddat$w_div
),
R2w = get_R2w(
select(ddat, pred, obs),
ddat$w_div
),
Weights = sum(ddat$w_div)
)
return(out)
}
) %>% bind_rows()
d_out[[i]]$Fraction <- fractions[i]
d_out[[i]]$Depth = w_depths
}
d_out %<>%
bind_rows() %>%
mutate(
Fraction = factor(Fraction, levels = fractions, labels = fraction_names)
)
tiff(
paste0(dir_results, "/depth_RMSEw_test_", testn, ".tiff"),
width = 16,
height = 10,
units = "cm",
res = 300
)
d_out %>%
ggplot(aes(x = RMSEw, y = Depth)) +
facet_wrap(~Fraction, nrow = 1, scales = "free_x") +
geom_path() +
scale_y_reverse(expand = c(0, 0))
try(dev.off())
try(dev.off())
tiff(
paste0(dir_results, "/depth_R2w_test_", testn, ".tiff"),
width = 16,
height = 10,
units = "cm",
res = 300
)
d_out %>%
ggplot(aes(x = R2w, y = Depth)) +
facet_wrap(~Fraction, nrow = 1, scales = "free_x") +
geom_path() +
scale_y_reverse(expand = c(0, 0))
try(dev.off())
try(dev.off())
tiff(
paste0(dir_results, "/depth_weights_test_", testn, ".tiff"),
width = 16,
height = 10,
units = "cm",
res = 300
)
d_out %>%
ggplot(aes(x = Weights, y = Depth)) +
facet_wrap(~Fraction, nrow = 1, scales = "free_x") +
geom_path() +
scale_y_reverse(expand = c(0, 0))
try(dev.off())
try(dev.off())
