imp_ogc %<>% mutate(
target = factor(
target,
levels = fractions,
labels = fraction_names
)
)
brks <- seq(
from = min(imp_ogc$dir),
by = (max(imp_ogc$dir) + 1 - min(imp_ogc$dir))/4,
length.out = 4
)
tiff(
paste0(dir_results, "/boot_importance_ogc_test", testn, ".tiff"),
width = 40,
height = 20,
units = "cm",
res = 300
)
ggplot(imp_ogc, aes(x = dir, y = Overall)) +
coord_polar(
start = - pi/2 - pi/(ndir_plot*2),
direction = -1) +
geom_polygon(colour = 'black', fill = rgb(0,2/3,2/3,1/2)) +
# geom_col(width = 1, colour = 'black', fill = rgb(0,2/3,2/3,1/2)) +
facet_wrap(
~ target,
ncol = 3
) +
scale_x_continuous(
breaks = brks,
labels = c('E', 'N', 'W', 'S')
) +
scale_y_continuous(limits = c(0, 100), expand = c(0, 0)) +
ylab('Covariate importance') +
theme_bw() +
theme(axis.text.x = element_text(
colour = 'black'),
axis.title.x = element_blank(),
axis.text.y = element_text(colour = 'black'),
panel.grid.major = element_line(color = 'grey'),
panel.grid.minor = element_blank(),
panel.border = element_rect(linewidth = 1)
)
try(dev.off())
# Standardize and transform predictions
boot_mean_predictions <- matrix(0, ncol = 6, nrow = nrow(obs))
for(i in 1:100) {
pred_boot_i <- data.frame(
clay = models_boot_predictions[[1]][, i],
silt = models_boot_predictions[[2]][, i],
coarse_sand = models_boot_predictions[[4]][, i],
SOC = models_boot_predictions[[5]][, i],
CaCO3 = models_boot_predictions[[6]][, i]
) %>%
mutate(
t_res = 100 - (clay + silt + coarse_sand),
clay = case_when(
t_res < 0 ~ clay*(100 + t_res)/100,
.default = clay
),
silt = case_when(
t_res < 0 ~ silt*(100 + t_res)/100,
.default = silt
),
coarse_sand = case_when(
t_res < 0 ~ coarse_sand*(100 + t_res)/100,
.default = coarse_sand
),
fine_sand = 100 - (clay + silt + coarse_sand)
) %>%
select(-t_res) %>%
relocate(any_of(fractions)) %>%
as.matrix()
boot_mean_predictions %<>% "+"(pred_boot_i)
}
boot_mean_predictions %<>%
"/"(100) %>%
round(digits = 1)
fine_sand_model_mean <- apply(models_boot_predictions[[3]], 1, mean)
cor(boot_mean_predictions[, 3], obs$fine_sand, use = "pairwise.complete.obs")^2
cor(fine_sand_model_mean, obs$fine_sand, use = "pairwise.complete.obs")^2
cor(fine_sand_model_mean, boot_mean_predictions[, 3], use = "pairwise.complete.obs")
saveRDS(
boot_mean_predictions,
paste0(dir_boot, "/models_boot_predictions_mean.rds")
)
# Inspect predictions
breaks <- c(0, 30, 60, 100, 200)
# Fine sand accuracy, based on method
finesand_acc <- data.frame(
pred_model = fine_sand_model_mean,
pred_residual = boot_mean_predictions[, 3],
observed = obs$fine_sand,
dataset = obs$fold,
w = models_weights[[3]],
upper = obs$upper,
lower = obs$lower
) %>%
filter(is.finite(observed)) %>% mutate(
indices = factor(dataset == 10, labels = c("CV", "Holdout")),
mean_d = (upper + lower)/2,
depth = cut(mean_d, breaks, include.lowest = TRUE)
) %>%
filter(is.finite(depth)) %>%
pivot_longer(
cols = c(pred_model, pred_residual),
names_to = "method",
values_to = "predicted"
) %>%
group_by(
indices, depth, method
) %>%
summarise(
r2w = round(get_R2w(cbind(predicted, observed), w), digits = 3),
rmsew = round(get_RMSEw(cbind(predicted, observed), w), digits = 3)
)
finesand_acc
write.table(
finesand_acc,
paste0(dir_results, "/boot_finesand_acc_test", testn, ".csv"),
sep = ";",
row.names = FALSE
)
# General accuracy for all observations
get_acc_all <- function(i2) {
lookup <- c(obs = fractions[i2])
dat_i <- obs %>%
mutate(
pred = boot_mean_predictions[, i2],
weights = models_weights[[i2]],
indices = factor(!models_indices[[i2]], labels = c("CV", "Holdout")),
bare = obs$s2_count_max10_fuzzy > 0,
bare = case_when(
is.na(bare) ~ 0,
.default = bare
),
mean_d = (upper + lower)/2,
depth = cut(mean_d, breaks, include.lowest = TRUE)
) %>%
rename(any_of(lookup)) %>%
filter(
is.finite(obs),
is.finite(pred),
is.finite(weights),
!is.na(depth)
)
if (i2 == 5) {
dat_i %<>% filter(
imputed == FALSE
)
}
out <- dat_i %>% group_by(indices, depth) %>%
summarise(
r2 = round(get_R2w(cbind(pred, obs), weights), digits = 3),
rmse = round(get_RMSEw(cbind(pred, obs), weights), digits = 3)
) %>%
mutate(Fraction = fraction_names[i2], .before = everything())
return(out)
}
acc_all <- foreach(i = 1:length(fractions), .combine = rbind) %do%
get_acc_all(i)
acc_all
write.table(
acc_all,
paste0(dir_results, "/boot_acc_all_test", testn, ".csv"),
sep = ";",
row.names = FALSE
)
# Accuracy for soils with less than 6% SOC
get_acc_lowsoc<- function(i2) {
lookup <- c(obs = fractions[i2])
out <- obs %>%
mutate(
pred = boot_mean_predictions[, i2],
weights = models_weights[[i2]],
indices = factor(!models_indices[[i2]], labels = c("CV", "Holdout")),
bare = obs$s2_count_max10_fuzzy > 0,
bare = case_when(
is.na(bare) ~ 0,
.default = bare
),
mean_d = (upper + lower)/2,
depth = cut(mean_d, breaks, include.lowest = TRUE),
imputed = obs$imputed
) %>%
rename(any_of(lookup)) %>%
filter(
is.finite(obs),
obs <= 6,
is.finite(pred),
is.finite(weights),
!is.na(depth),
imputed == FALSE
) %>% group_by(indices, depth) %>%
summarise(
r2 = round(get_R2w(cbind(pred, obs), weights), digits = 3),
rmse = round(get_RMSEw(cbind(pred, obs), weights), digits = 3)
) %>%
mutate(Fraction = fraction_names[i2], .before = everything())
return(out)
}
acc_lowsoc <- get_acc_lowsoc(5)
acc_lowsoc
write.table(
acc_lowsoc,
paste0(dir_results, "/boot_acc_lowsoc_test", testn, ".csv"),
sep = ";",
row.names = FALSE
)
# Accuracy for soils with less than 6% SOC
get_acc_highsoc<- function(i2) {
lookup <- c(obs = fractions[i2])
out <- obs %>%
mutate(
pred = boot_mean_predictions[, i2],
weights = models_weights[[i2]],
indices = factor(!models_indices[[i2]], labels = c("CV", "Holdout")),
bare = obs$s2_count_max10_fuzzy > 0,
bare = case_when(
is.na(bare) ~ 0,
.default = bare
),
mean_d = (upper + lower)/2,
depth = cut(mean_d, breaks, include.lowest = TRUE),
imputed = obs$imputed
) %>%
rename(any_of(lookup)) %>%
filter(
is.finite(obs),
obs > 6,
is.finite(pred),
is.finite(weights),
!is.na(depth),
imputed == FALSE
) %>% group_by(indices, depth) %>%
summarise(
r2w = round(get_R2w(cbind(pred, obs), weights), digits = 3),
rmsew = round(get_RMSEw(cbind(pred, obs), weights), digits = 3),
r2 = round(cor(pred, obs)^2, digits = 3),
rmse = round(rmse(pred, obs), digits = 3)
) %>%
mutate(Fraction = fraction_names[i2], .before = everything())
return(out)
}
acc_highsoc <- get_acc_highsoc(5)
?rmse
?RMSE
get_acc_highsoc<- function(i2) {
lookup <- c(obs = fractions[i2])
out <- obs %>%
mutate(
pred = boot_mean_predictions[, i2],
weights = models_weights[[i2]],
indices = factor(!models_indices[[i2]], labels = c("CV", "Holdout")),
bare = obs$s2_count_max10_fuzzy > 0,
bare = case_when(
is.na(bare) ~ 0,
.default = bare
),
mean_d = (upper + lower)/2,
depth = cut(mean_d, breaks, include.lowest = TRUE),
imputed = obs$imputed
) %>%
rename(any_of(lookup)) %>%
filter(
is.finite(obs),
obs > 6,
is.finite(pred),
is.finite(weights),
!is.na(depth),
imputed == FALSE
) %>% group_by(indices, depth) %>%
summarise(
r2w = round(get_R2w(cbind(pred, obs), weights), digits = 3),
rmsew = round(get_RMSEw(cbind(pred, obs), weights), digits = 3),
r2 = round(cor(pred, obs)^2, digits = 3),
rmse = round(RMSE(cbind(pred, obs)), digits = 3)
) %>%
mutate(Fraction = fraction_names[i2], .before = everything())
return(out)
}
acc_highsoc <- get_acc_highsoc(5)
get_acc_highsoc<- function(i2) {
lookup <- c(obs = fractions[i2])
out <- obs %>%
mutate(
pred = boot_mean_predictions[, i2],
weights = models_weights[[i2]],
indices = factor(!models_indices[[i2]], labels = c("CV", "Holdout")),
bare = obs$s2_count_max10_fuzzy > 0,
bare = case_when(
is.na(bare) ~ 0,
.default = bare
),
mean_d = (upper + lower)/2,
depth = cut(mean_d, breaks, include.lowest = TRUE),
imputed = obs$imputed
) %>%
rename(any_of(lookup)) %>%
filter(
is.finite(obs),
obs > 6,
is.finite(pred),
is.finite(weights),
!is.na(depth),
imputed == FALSE
) %>% group_by(indices, depth) %>%
summarise(
r2w = round(get_R2w(cbind(pred, obs), weights), digits = 3),
rmsew = round(get_RMSEw(cbind(pred, obs), weights), digits = 3),
r2 = round(cor(pred, obs)^2, digits = 3),
rmse = round(RMSE(pred, obs), digits = 3)
) %>%
mutate(Fraction = fraction_names[i2], .before = everything())
return(out)
}
acc_highsoc <- get_acc_highsoc(5)
acc_highsoc
write.table(
acc_highsoc,
paste0(dir_results, "/boot_acc_highsoc_test", testn, ".csv"),
sep = ";",
row.names = FALSE
)
source("C:/Users/au542768/digijord/digijord_code/10c_map_texture_somremoval.R")
# Procedure:
# For depth 1:
## For each tile:
### For each bootstrap iteration:
#### Predict texture fractions with and without som removal (tmp)
#### Standardize texture predictions (tmp)
#### Calculate differences for mineral texture fractions (tmp)
#### Predict SOC and CaCO3 only once (tmp)
#### Map soil texture class with and without som removal (tmp)
#### Calculate differences for texture classes (tmp)
### Summarize texture without SOM removal (save)
### Summarize only mean value for SOC and CaCO3 (save)
### Summarize texture classes without SOM removal (save)
### Summarize differences for texture with and without som removal (save)
### Summarize differences for texture classes (save)
## Merge maps of summarized mineral fractions classes (save)
library(parallel)
library(caret)
library(terra)
library(magrittr)
library(dplyr)
library(xgboost)
library(foreach)
library(stringr)
library(tools) # file_path_sans_ext
dir_code <- getwd()
root <- dirname(dir_code)
dir_dat <- paste0(root, "/digijord_data/")
testn <- 14
mycrs <- "EPSG:25832"
dir_results <- dir_dat %>%
paste0(., "/results_test_", testn, "/")
fractions_alt <- c("clay", "silt", "fine_sand", "coarse_sand", "SOC", "CaCO3")
fractions <- fractions_alt
frac_ind_mineral <- c(1:4)
frac_ind_predict <- c(1:length(fractions))[-3]  # Exclude fine sand
fraction_names <- c(
"Clay", "Silt", "Fine sand", "Coarse sand", "SOC", "CaCO3"
)
fraction_names_underscore <- c(
"Clay", "Silt", "Fine_sand", "Coarse_sand", "SOC", "CaCO3"
)
dir_cov <- dir_dat %>% paste0(., "/covariates")
cov_files <- dir_cov %>% list.files()
cov_names <- cov_files %>% tools::file_path_sans_ext()
cov_cats <- dir_code %>%
paste0(., "/cov_categories_20231110.csv") %>%
read.table(
sep = ",",
header = TRUE
)
# cov_selected <- cov_cats %>%
#   filter(anbm_use == 1) %>%
#   dplyr::select(., name) %>%
#   unlist() %>%
#   unname()
source("f_predict_passna.R")
# Path for loading bootstrap models
dir_boot <- dir_results %>%
paste0(., "/bootstrap/")
dir_boot_models <- dir_boot %>%
paste0(., "/models/")
dir_boot_models_fractions <- dir_boot_models %>%
paste0(., "/", fractions, "/")
models_boot_files <- lapply(
1:length(fractions),
function(x) {
out <- fractions[x] %>%
paste0(dir_boot_models, "/", ., "/") %>%
list.files(full.names = TRUE)
return(out)
}
)
# Tiles for model prediction
numCores <- detectCores() - 1
numCores
dir_tiles <- dir_dat %>%
paste0(., "/tiles_591/")
subdir_tiles <- dir_tiles %>%
list.dirs() %>%
.[-1]
tilenames <- basename(subdir_tiles)
# Directory for saving bootstrap predictions
dir_pred_boot <- dir_boot %>%
paste0(., "/predictions_difference/") %T>%
dir.create(showWarnings = FALSE, recursive = TRUE)
dir_pred_tiles <- dir_pred_boot %>%
paste0(., "/tiles/") %T>%
dir.create(showWarnings = FALSE, recursive = TRUE)
# Directory for temporary texture predictions, for standardization
# Overwrite for each depth + bootstrap repetition
dir_pred_tiles_tmp <- dir_pred_tiles %>%
paste0(., "/tmp_fractions/") %T>%
dir.create(showWarnings = FALSE, recursive = TRUE)
for (x in 1:length(tilenames)) {
dir_pred_tiles_tmp %>%
paste0(., "/", tilenames[x], "/") %T>%
dir.create(showWarnings = FALSE, recursive = TRUE)
}
dir_boot_sum_tiles <- dir_pred_boot %>%
paste0(., "/summary/") %T>%
dir.create(showWarnings = FALSE)
# Set number of bootstrap repetitions to use
nboot <- lapply(
models_boot_files,
function(x) {
out <- length(x)
return(out)
}
) %>%
unlist() %>%
min()
nboot_final <- 100
nboot_max <- 100
# nboot_max <- 100
nboot <- min(c(nboot, nboot_max))
boot_all_chr <- c(1:nboot) %>%
str_pad(
.,
nchar(nboot_final),
pad = "0"
) %>%
paste0("boot_", .)
# Set up loop for predicting each soil depth
n_digits <- 1
breaks <- c(0, 30, 60, 100, 200)
max_char <- breaks %>%
as.character() %>%
nchar() %>%
max()
breaks_chr <- breaks %>%
str_pad(
.,
max_char,
pad = "0"
)
j_all_depths <- 1:(length(breaks) - 1)
j_only_top <- 1
only_top <- TRUE
# # only_top <- FALSE
if (only_top) {
j_depth <- j_only_top
} else {
j_depth <- j_all_depths
}
expand.grid(
bootr = 1:nboot,
fraction_ind = frac_ind_predict,
som_removed = c(0, 1)
)
bind_rows(
expand.grid(
bootr = 1:nboot,
fraction_ind = frac_ind_mineral[frac_ind_mineral %in% frac_ind_predict],
som_removed = c(0, 1)
),
expand.grid(
bootr = 1:nboot,
fraction_ind = frac_ind_predict[!frac_ind_predict %in% frac_ind_mineral],
som_removed = NA
)
)
bind_rows(
expand.grid(
bootr = 1:nboot,
fraction_ind = frac_ind_mineral[frac_ind_mineral %in% frac_ind_predict],
som_removed = c(0, 1)
),
expand.grid(
bootr = 1:nboot,
fraction_ind = frac_ind_predict[!frac_ind_predict %in% frac_ind_mineral],
som_removed = NA
)
) %>% plot()
pred_combinations <- bind_rows(
expand.grid(
bootr = 1:nboot,
fraction_ind = frac_ind_mineral[frac_ind_mineral %in% frac_ind_predict],
som_removed = c(0, 1)
),
expand.grid(
bootr = 1:nboot,
fraction_ind = frac_ind_predict[!frac_ind_predict %in% frac_ind_mineral],
som_removed = NA
)
)
